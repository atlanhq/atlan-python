
        @staticmethod
        def generate_qualified_name(
            name: str,
            connection_qualified_name: str,
            inputs: List["Catalog"],
            outputs: List["Catalog"],
            parent: Optional["Process"] = None,
            process_id: Optional[str] = None,
            extra_hash_params: Optional[Set[str]] = None,
        ) -> str:
            def append_relationship(output: StringIO, relationship: Asset):
                if relationship.guid:
                    output.write(relationship.guid)

            def append_relationships(output: StringIO, relationships: List["Catalog"]):
                for catalog in relationships:
                    append_relationship(output, catalog)

            validate_required_fields(
                ["name", "connection_qualified_name", "inputs", "outputs"],
                [name, connection_qualified_name, inputs, outputs],
            )
            extra_hash_params = extra_hash_params or set()
            if process_id and process_id.strip():
                return f"{connection_qualified_name}/{process_id}"
            buffer = StringIO()
            buffer.write(name)
            buffer.write(connection_qualified_name)
            if parent:
                append_relationship(buffer, parent)
            append_relationships(buffer, inputs)
            append_relationships(buffer, outputs)
            # Handles edge case where identical name, connection, input, and output caused hash collisions,
            # resulting in duplicate qualified names and backend skipping process creation.
            if extra_hash_params:
                for param in extra_hash_params:
                    buffer.write(param)
            # file deepcode ignore InsecureHash: this is not used for generating security keys
            ret_value = hashlib.md5(  # noqa: S303, S324
                buffer.getvalue().encode()
            ).hexdigest()
            buffer.close()
            return f"{connection_qualified_name}/{ret_value}"

        @classmethod
        @init_guid
        def create(
            cls,
            name: str,
            connection_qualified_name: str,
            inputs: List["Catalog"],
            outputs: List["Catalog"],
            process_id: Optional[str] = None,
            parent: Optional[Process] = None,
            extra_hash_params: Optional[Set[str]] = None,
        ) -> Process.Attributes:
            qualified_name = Process.Attributes.generate_qualified_name(
                name=name,
                connection_qualified_name=connection_qualified_name,
                process_id=process_id,
                inputs=inputs,
                outputs=outputs,
                parent=parent,
                extra_hash_params=extra_hash_params,
            )
            connector_name = connection_qualified_name.split("/")[1]
            return Process.Attributes(
                name=name,
                qualified_name=qualified_name,
                connector_name=connector_name,
                connection_qualified_name=connection_qualified_name,
                inputs=inputs,
                outputs=outputs,
            )

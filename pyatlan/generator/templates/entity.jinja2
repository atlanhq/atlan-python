# SPDX-License-Identifier: Apache-2.0
# Copyright 2022 Atlan Pte. Ltd.
# Based on original code from https://github.com/apache/atlas (under Apache-2.0 license)
from __future__ import annotations

import hashlib
import sys
from datetime import datetime
from io import StringIO
from typing import Any, ClassVar, Dict, List, Optional, Set, Type, TypeVar
from urllib.parse import quote, unquote

from pydantic import Field, PrivateAttr, StrictStr, root_validator, validator

from pyatlan.model.core import Announcement, AtlanObject, Classification, Meaning
from pyatlan.model.custom_metadata import CustomMetadataDict, CustomMetadataProxy
from pyatlan.model.enums import (
    ADLSAccessTier,
    ADLSAccountStatus,
    ADLSEncryptionTypes,
    ADLSLeaseState,
    ADLSLeaseStatus,
    ADLSObjectArchiveStatus,
    ADLSObjectType,
    ADLSPerformance,
    ADLSProvisionState,
    ADLSReplicationType,
    ADLSStorageKind,
    AnnouncementType,
    AtlanConnectorType,
    AuthPolicyCategory,
    AuthPolicyResourceCategory,
    AuthPolicyType,
    CertificateStatus,
    DataAction,
    EntityStatus,
    FileType,
    GoogleDatastudioAssetType,
    IconType,
    KafkaTopicCompressionType,
    PersonaGlossaryAction,
    PersonaMetadataAction,
    PowerbiEndorsement,
    PurposeMetadataAction,
    QueryUsernameStrategy,
    QuickSightAnalysisStatus,
    QuickSightDatasetFieldType,
    QuickSightDatasetImportMode,
    QuickSightFolderType,
    SourceCostUnitType,
)
from pyatlan.model.internal import AtlasServer, Internal
from pyatlan.model.structs import (
    AuthPolicyCondition,
    AuthPolicyValiditySchedule,
    AwsTag,
    AzureTag,
    BadgeCondition,
    ColumnValueFrequencyMap,
    DbtMetricFilter,
    GoogleLabel,
    GoogleTag,
    Histogram,
    KafkaTopicConsumption,
    MCRuleComparison,
    MCRuleSchedule,
    PopularityInsights,
    SourceTagAttribute,
)
from pyatlan.utils import next_id, validate_required_fields



def validate_single_required_field(field_names: list[str], values: list[Any]):
    indexes = [idx for idx, value in enumerate(values) if value is not None]
    if not indexes:
        raise ValueError(
            f"One of the following parameters are required: {', '.join(field_names)}"
        )
    if len(indexes) > 1:
        names = [field_names[idx] for idx in indexes]
        raise ValueError(
            f"Only one of the following parameters are allowed: {', '.join(names)}"
        )


{% from 'macros.jinja2' import gen_properties %}
SelfAsset = TypeVar("SelfAsset", bound="Asset")
{% for entity_def in entity_defs %}
{%- set super_classes = ['AtlanObject'] if not entity_def.super_types else entity_def.super_types -%}
class {{ entity_def.name }}({{super_classes[0]}} {%- if "Asset" in super_classes  %}, type_name='{{ entity_def.name }}'{% endif %}):
    """Description"""
{% if entity_def.name == "Referenceable" %}
    def __init__(__pydantic_self__, **data: Any) -> None:
        super().__init__(**data)
        __pydantic_self__.__fields_set__.update(["attributes", "type_name"])
        __pydantic_self__._metadata_proxy = CustomMetadataProxy(
            __pydantic_self__.business_attributes
        )

    def json(self, *args, **kwargs) -> str:
        self.business_attributes = self._metadata_proxy.business_attributes
        return super().json(**kwargs)
{% endif %}
    def __setattr__(self, name, value):
            if name in {{ entity_def.name }}._convience_properties:
                return object.__setattr__(self, name, value)
            super().__setattr__( name, value)

    {{ gen_properties(entity_def.attribute_defs + entity_def.relationship_attribute_defs, list_overrides) }}

{%- if entity_def.name == "Referenceable"  %}

    class Attributes(AtlanObject):
        {%- for attribute_def in entity_def.attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {%- set default_value = "''" if attribute_def.name == "qualifiedName" else "None" %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field({{ default_value }}, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
        {%- for attribute_def in entity_def.relationship_attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='',  alias='{{attribute_def.name}}') # relationship
        {%- endfor %}

        def validate_required(self):
            pass

    _metadata_proxy: CustomMetadataProxy = PrivateAttr()
    attributes: '{{entity_def.name}}.Attributes' = Field(
        default_factory = lambda : {{entity_def.name}}.Attributes(),
        description='Map of attributes in the instance and their values. The specific keys of this map will vary '
                    'by type, so are described in the sub-types of this schema.\n',
    )
    business_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Map of custom metadata attributes and values defined on the entity.\n',
        alias='businessAttributes'
    )
    created_by: Optional[str] = Field(
        None,
        description='Username of the user who created the object.\n',
        example='jsmith',
    )
    create_time: Optional[int] = Field(
        None,
        description='Time (epoch) at which this object was created, in milliseconds.\n',
        example=1648852296555,
    )
    delete_handler: Optional[str] = Field(
        None,
        description="Details on the handler used for deletion of the asset.",
        example="Hard",
    )
    guid: str = Field(
        "",
        description='Unique identifier of the entity instance.\n',
        example='917ffec9-fa84-4c59-8e6c-c7b114d04be3',
    )
    is_incomplete: Optional[bool] = Field(True, description='', example=True)
    labels: Optional[List[str]] = Field(None, description='Internal use only.')
    relationship_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Map of relationships for the entity. The specific keys of this map will vary by type, '
                    'so are described in the sub-types of this schema.\n',
    )
    status: Optional[EntityStatus] = Field(
        None,
        description="Status of the entity",
        example=EntityStatus.ACTIVE
    )
    type_name: str = Field(
        None, description='Name of the type definition that defines this instance.\n'
    )
    updated_by: Optional[str] = Field(
        None,
        description='Username of the user who last assets_updated the object.\n',
        example='jsmith',
    )
    update_time: Optional[int] = Field(
        None,
        description='Time (epoch) at which this object was last assets_updated, in milliseconds.\n',
        example=1649172284333,
    )
    version: Optional[int] = Field(
        None, description='Version of this object.\n', example=2
    )
    classifications: Optional[list[Classification]] = Field(
        None, description="classifications"
    )
    classification_names: Optional[list[str]] = Field(
        None, description="The names of the classifications that exist on the asset."
    )
    display_text: Optional[str] = Field(
        None,
        description="Human-readable name of the entity..\n",
    )
    entity_status: Optional[str] = Field(
        None,
        description="Status of the entity (if this is a related entity).\n",
    )
    relationship_guid: Optional[str] = Field(
        None,
        description="Unique identifier of the relationship (when this is a related entity).\n",
    )
    relationship_status: Optional[str] = Field(
        None,
        description="Status of the relationship (when this is a related entity).\n",
    )
    relationship_type: Optional[str] = Field(
        None,
        description="Status of the relationship (when this is a related entity).\n",
    )
    meaning_names: Optional[list[str]] = Field(
        None, description="Names of assigned_terms that have been linked to this asset."
    )
    meanings: Optional[list[Meaning]] = Field(
        None, description="", alias="meanings"
    )
    custom_attributes: Optional[dict[str, Any]] = Field(None, description="", alias="customAttributes")
    scrubbed: Optional[bool] = Field(
        None, description="", alias="fields removed from results"
    )
    pending_tasks: Optional[list[str]] = Field(None)

    unique_attributes: Optional[dict[str, Any]] = Field(None)

    def validate_required(self):
        if not self.create_time or self.created_by:
            self.attributes.validate_required()

    def get_custom_metadata(self, name: str) -> CustomMetadataDict:
        return self._metadata_proxy.get_custom_metadata(name=name)

    def set_custom_metadata(self, custom_metadata: CustomMetadataDict):
        return self._metadata_proxy.set_custom_metadata(custom_metadata=custom_metadata)

    def flush_custom_metadata(self):
        self.business_attributes = self._metadata_proxy.business_attributes


{%- else %}
    {%- if entity_def.name == "Asset"  %}
    _subtypes_:dict[str, type] = dict()

    def __init_subclass__(cls, type_name=None):
        cls._subtypes_[type_name or cls.__name__.lower()] = cls

    def trim_to_required(self:SelfAsset) -> SelfAsset:
        return self.create_for_modification(qualified_name=self.qualified_name, name=self.name)

    @classmethod
    def create(cls:Type[SelfAsset], *args, **kwargs)->SelfAsset:
        raise NotImplementedError("Create has not been implemented for this class. Please submit an enhancement"
                                  "request if you need it implemented.")

    @classmethod
    def create_for_modification(
        cls: type[SelfAsset], qualified_name: str = "", name: str = ""
    ) -> SelfAsset:
        validate_required_fields(
            ["name", "qualified_name"],
            [name, qualified_name],
        )
        return cls(attributes=cls.Attributes(qualified_name=qualified_name, name=name))

    @classmethod
    def ref_by_guid(cls: type[SelfAsset], guid: str) -> SelfAsset:
        retval: SelfAsset = cls(attributes=cls.Attributes())
        retval.guid = guid
        return retval

    @classmethod
    def ref_by_qualified_name(cls: type[SelfAsset], qualified_name: str) -> SelfAsset:
        ret_value: SelfAsset = cls(
            attributes=cls.Attributes(qualified_name=qualified_name)
        )
        ret_value.unique_attributes = {"qualifiedName": qualified_name}
        return ret_value

    @classmethod
    def __get_validators__(cls):
        yield cls._convert_to_real_type_

    @classmethod
    def _convert_to_real_type_(cls, data):

        if isinstance(data, Asset):
            return data

        data_type = (
            data.get("type_name") if "type_name" in data else data.get("typeName")
        )

        if data_type is None:
            if issubclass(cls, Asset):
                return cls(**data)
            raise ValueError("Missing 'type' in Asset")

        sub = cls._subtypes_.get(data_type)
        if sub is None:
            sub = getattr(sys.modules[__name__], data_type)


        if sub is None:
            raise TypeError(f"Unsupport sub-type: {data_type}")

        return sub(**data)
    {%- endif %}
    type_name: str = Field("{{ entity_def.name }}", allow_mutation=False)

    @validator('type_name')
    def validate_type_name(cls, v):
        if v != "{{ entity_def.name }}":
            raise ValueError('must be {{ entity_def.name }}')
        return v

    {%- if entity_def.name == "Badge" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: StrictStr,
        cm_name: str,
        cm_attribute: str,
        badge_conditions: list[BadgeCondition],
    ) -> Badge:
        return cls(
            status = EntityStatus.ACTIVE,
            attributes=Badge.Attributes.create(
                name=name,
                cm_name=cm_name,
                cm_attribute=cm_attribute,
                badge_conditions=badge_conditions,
            )
        )
    {%- elif entity_def.name == "Readme" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls, *, asset: Asset, content: str, asset_name: Optional[str] = None
    ) -> Readme:
        return Readme(
            attributes=Readme.Attributes.create(
                asset=asset, content=content, asset_name=asset_name
            )
        )

    @property
    def description(self) -> Optional[str]:
        ret_value = self.attributes.description
        return unquote(ret_value) if ret_value is not None else ret_value

    @description.setter
    def description(self, description: Optional[str]):
        if self.attributes is None:
            self.attributes = self.Attributes()
        self.attributes.description = (
            quote(description) if description is not None else description
        )
    {%- endif %}
    {%- if entity_def.attribute_defs or entity_def.relationship_attribute_defs %}
    class Attributes({{super_classes[0]}}.Attributes):
        {%- for attribute_def in entity_def.attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{% if attribute_def.name in list_overrides %}{{list_overrides.get(attribute_def.name)}}{% else %}{{type}}{% endif %}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='' , alias='{{attribute_def.name}}')
        {%- endfor %}
        {%- for attribute_def in entity_def.relationship_attribute_defs %}
        {%- set type = attribute_def.typeName | get_type %}
        {{attribute_def.name | to_snake_case }}: {% if attribute_def.isOptional %}Optional[{% endif %}{{type}}{% if attribute_def.isOptional %}]{% endif %} = Field(None, description='',  alias='{{attribute_def.name}}') # relationship
        {%- endfor %}
        {%- if entity_def.name == "Asset"  %}
        def remove_description(self):
            self.description = None

        def remove_user_description(self):
            self.user_description = None

        def remove_owners(self):
            self.owner_groups = None
            self.owner_users = None

        def remove_certificate(self):
            self.certificate_status = None
            self.certificate_status_message = None

        def remove_announcement(self):
            self.announcement_message = None
            self.announcement_title = None
            self.announcement_type = None
        {%- endif  %}
        {%- if entity_def.name == "Process" %}
        @staticmethod
        def generate_qualified_name(
            name: str,
            connection_qualified_name: str,
            inputs: list["Catalog"],
            outputs: list["Catalog"],
            parent: Optional["Process"] = None,
            process_id: Optional[str] = None,
        ) -> str:
            def append_relationship(output: StringIO, relationship: Asset):
                if relationship.guid:
                    output.write(relationship.guid)

            def append_relationships(output: StringIO, relationships: list["Catalog"]):
                for catalog in relationships:
                    append_relationship(output, catalog)

            validate_required_fields(
                ["name", "connection_qualified_name", "inputs", "outputs"],
                [name, connection_qualified_name, inputs, outputs],
            )
            if process_id and process_id.strip():
                return f"{connection_qualified_name}/{process_id}"
            buffer = StringIO()
            buffer.write(name)
            buffer.write(connection_qualified_name)
            if parent:
                append_relationship(buffer, parent)
            append_relationships(buffer, inputs)
            append_relationships(buffer, outputs)
            ret_value = hashlib.md5(
                buffer.getvalue().encode(), usedforsecurity=False
            ).hexdigest()
            buffer.close()
            return ret_value

        @classmethod
        def create(
            cls,
            name: str,
            connection_qualified_name: str,
            inputs: list["Catalog"],
            outputs: list["Catalog"],
            process_id: Optional[str] = None,
            parent: Optional[Process] = None,
        ) -> Process.Attributes:
            qualified_name = Process.Attributes.generate_qualified_name(
                name=name,
                connection_qualified_name=connection_qualified_name,
                process_id=process_id,
                inputs=inputs,
                outputs=outputs,
                parent=parent,
            )
            connector_name = connection_qualified_name.split("/")[1]
            return Process.Attributes(
                name=name,
                qualified_name=qualified_name,
                connector_name=connector_name,
                connection_qualified_name=connection_qualified_name,
                inputs=inputs,
                outputs=outputs,
            )
        {%- elif entity_def.name == "Badge"  %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: StrictStr,
            cm_name: str,
            cm_attribute: str,
            badge_conditions: list[BadgeCondition],
        ) -> Badge.Attributes:
            validate_required_fields(
                ["name", "cm_name", "cm_attribute", "badge_conditions"],
                [name, cm_name, cm_attribute, badge_conditions],
            )
            from pyatlan.cache.custom_metadata_cache import CustomMetadataCache

            cm_id = CustomMetadataCache.get_id_for_name(cm_name)
            cm_attr_id = CustomMetadataCache.get_attr_id_for_name(
                set_name=cm_name, attr_name=cm_attribute
            )
            return Badge.Attributes(
                name=name,
                qualified_name=f"badges/global/{cm_id}.{cm_attr_id}",
                badge_metadata_attribute=f"{cm_id}.{cm_attr_id}",
                badge_conditions=badge_conditions,
            )
        {%- elif entity_def.name == "Readme"  %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, asset: Asset, content: str, asset_name: Optional[str] = None
        ) -> Readme.Attributes:
            validate_required_fields(["asset", "content"], [asset, content])
            if not asset.name:
                if not asset_name:
                    raise ValueError(
                        "asset_name is required when name is not available from asset"
                    )
            elif asset_name:
                raise ValueError(
                    "asset_name can not be given when name is available from asset"
                )
            else:
                asset_name = asset.name
            return Readme.Attributes(
                qualified_name=f"{asset.guid}/readme",
                name=f"{asset_name} Readme",
                asset=asset,
                description=quote(content),
            )
        {%- elif entity_def.name == "Database"  %}
        @classmethod
        # @validate_arguments()
        def create(cls, name: str, connection_qualified_name: str)->{{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["connection_qualified_name"], [connection_qualified_name])
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1]) # type:ignore
            except ValueError as e:
                raise ValueError("Invalid connection_qualified_name") from e
            return Database.Attributes(
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{name}",
                connector_name=connector_type.value,
            )
        {%-  elif entity_def.name == "Schema" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, name: str, database_qualified_name: str
        ) -> Schema.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(
                ["database_qualified_name"], [database_qualified_name]
            )
            fields = database_qualified_name.split("/")
            if len(fields) != 4:
                raise ValueError("Invalid database_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError as e:
                raise ValueError("Invalid database_qualified_name") from e
            return Schema.Attributes(
                name=name,
                database_name=fields[3],
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                database_qualified_name=database_qualified_name,
                qualified_name=f"{database_qualified_name}/{name}",
                connector_name=connector_type.value,
                database=Database.ref_by_qualified_name(database_qualified_name),
            )
        {%- elif entity_def.name == "Table" or entity_def.name == "View" or entity_def.name == "MaterialisedView" %}
        @classmethod
        # @validate_arguments()
        def create(cls, *, name: str, schema_qualified_name: str) -> {{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["schema_qualified_name"], [schema_qualified_name])
            fields = schema_qualified_name.split("/")
            if len(fields) != 5:
                raise ValueError("Invalid schema_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError as e:
                raise ValueError("Invalid schema_qualified_name") from e
            return {{  entity_def.name }}.Attributes(
                name=name,
                database_name=fields[3],
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                database_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}",
                qualified_name=f"{schema_qualified_name}/{name}",
                schema_qualified_name=schema_qualified_name,
                schema_name=fields[4],
                connector_name=connector_type.value,
                atlan_schema=Schema.ref_by_qualified_name(schema_qualified_name),
            )
        {%- elif entity_def.name == "Column" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, name: str, parent_qualified_name: str, parent_type: type, order: int
        ) -> Column.Attributes:
            validate_required_fields(
                ["name", "parent_qualified_name", "parent_type", "order"],
                [name, parent_qualified_name, parent_type, order],
            )
            fields = parent_qualified_name.split("/")
            if len(fields) != 6:
                raise ValueError("Invalid parent_qualified_name")
            try:
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
            except ValueError as e:
                raise ValueError("Invalid parent_qualified_name") from e
            if order < 0:
                raise ValueError("Order must be be a positive integer")
            ret_value = Column.Attributes(
                name=name,
                qualified_name=f"{parent_qualified_name}/{name}",
                connector_name=connector_type.value,
                schema_name=fields[4],
                schema_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}/{fields[4]}",
                database_name=fields[3],
                database_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}/{fields[3]}",
                connection_qualified_name=f"{fields[0]}/{fields[1]}/{fields[2]}",
                order=order,
            )
            if parent_type == Table:
                ret_value.table_qualified_name = parent_qualified_name
                ret_value.table = Table.ref_by_qualified_name(parent_qualified_name)
                ret_value.table_name = fields[5]
            elif parent_type == View:
                ret_value.view_qualified_name = parent_qualified_name
                ret_value.view = View.ref_by_qualified_name(parent_qualified_name)
                ret_value.view_name = fields[5]
            elif parent_type == MaterialisedView:
                ret_value.view_qualified_name = parent_qualified_name
                ret_value.materialised_view = MaterialisedView.ref_by_qualified_name(
                    parent_qualified_name
                )
                ret_value.view_name = fields[5]
            else:
                raise ValueError(
                    "parent_type must be either Table, View or MaterializeView"
                )
            return ret_value

    @classmethod
    # @validate_arguments()
    def create(
        cls, *, name: str, parent_qualified_name: str, parent_type: type, order: int
    ) -> Column:
        return Column(
            attributes=Column.Attributes.create(
                name=name,
                parent_qualified_name=parent_qualified_name,
                parent_type=parent_type,
                order=order,
            )
        )
        {%- elif entity_def.name == "S3Bucket" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls, *, name: str, connection_qualified_name: str, aws_arn: str
        ) -> {{ entity_def.name }}.Attributes:
            validate_required_fields(
                ["name", "connection_qualified_name", "aws_arn"],
                [name, connection_qualified_name, aws_arn],
            )
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                if fields[0].replace(" ", "") == "" or fields[2].replace(" ", "") == "":
                    raise ValueError("Invalid connection_qualified_name")
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
                if connector_type != AtlanConnectorType.S3:
                    raise ValueError("Connector type must be s3")
            except ValueError as e:
                raise ValueError("Invalid connection_qualified_name") from e
            return {{ entity_def.name }}.Attributes(
                aws_arn=aws_arn,
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{aws_arn}",
                connector_name=connector_type.value,
            )
        {%- elif entity_def.name == "S3Object" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: str,
            connection_qualified_name: str,
            aws_arn: str,
            s3_bucket_qualified_name: Optional[str] = None,
        ) -> S3Object.Attributes:
            validate_required_fields(
                ["name", "connection_qualified_name", "aws_arn"],
                [name, connection_qualified_name, aws_arn],
            )
            fields = connection_qualified_name.split("/")
            if len(fields) != 3:
                raise ValueError("Invalid connection_qualified_name")
            try:
                if fields[0].replace(" ", "") == "" or fields[2].replace(" ", "") == "":
                    raise ValueError("Invalid connection_qualified_name")
                connector_type = AtlanConnectorType(fields[1])  # type:ignore
                if connector_type != AtlanConnectorType.S3:
                    raise ValueError("Connector type must be s3")
            except ValueError as e:
                raise ValueError("Invalid connection_qualified_name") from e
            return S3Object.Attributes(
                aws_arn=aws_arn,
                name=name,
                connection_qualified_name=connection_qualified_name,
                qualified_name=f"{connection_qualified_name}/{aws_arn}",
                connector_name=connector_type.value,
                s3_bucket_qualified_name=s3_bucket_qualified_name,
            )
        {%- elif entity_def.name == "AtlasGlossary" %}
        @classmethod
        # @validate_arguments()
        def create(cls, *, name: StrictStr)->{{ entity_def.name }}.Attributes:
            validate_required_fields(["name"], [name])
            return AtlasGlossary.Attributes(name=name, qualified_name=next_id())
        {%- elif entity_def.name == "AtlasGlossaryCategory" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: StrictStr,
            anchor: AtlasGlossary,
            parent_category: Optional[AtlasGlossaryCategory] = None,
        ) -> AtlasGlossaryCategory.Attributes:
            validate_required_fields(["name", "anchor"], [name, anchor])
            return AtlasGlossaryCategory.Attributes(
                name=name, anchor=anchor, parent_category=parent_category, qualified_name=next_id()
            )
        {%- elif entity_def.name == "AtlasGlossaryTerm" %}
        @classmethod
        # @validate_arguments()
        def create(
            cls,
            *,
            name: StrictStr,
            anchor: Optional[AtlasGlossary] = None,
            glossary_qualified_name: Optional[StrictStr] = None,
            glossary_guid: Optional[StrictStr] = None,
            categories: Optional[list[AtlasGlossaryCategory]] = None,
        ) -> AtlasGlossaryTerm.Attributes:
            validate_required_fields(["name"], [name])
            validate_single_required_field(
                ["anchor", "glossary_qualified_name", "glossary_guid"],
                [anchor, glossary_qualified_name, glossary_guid],
            )
            if glossary_qualified_name:
                anchor = AtlasGlossary()
                anchor.unique_attributes = {"qualifiedName": glossary_qualified_name}
            if glossary_guid:
                anchor = AtlasGlossary()
                anchor.guid = glossary_guid
            return AtlasGlossaryTerm.Attributes(
                name=name,
                anchor=anchor,
                categories=categories,
                qualified_name=next_id(),
            )
        {%- elif entity_def.name == "Persona"  %}
        @classmethod
        # @validate_arguments()
        def create(cls, name: str) -> {{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["name"], [name])
            return Persona.Attributes(
                qualified_name=name,
                name=name,
                display_name=name,
                is_access_control_enabled=True,
                description=""
            )
        {%- elif entity_def.name == "Purpose"  %}
        @classmethod
        # @validate_arguments()
        def create(cls, name: str, classifications: list[str]) -> {{ entity_def.name }}.Attributes:
            validate_required_fields(["name", "classifications"], [name, classifications])
            return Purpose.Attributes(
                qualified_name=name,
                name=name,
                display_name=name,
                is_access_control_enabled=True,
                description="",
                purpose_classifications=classifications
            )
        {%- elif entity_def.name == "AuthPolicy"  %}
        @classmethod
        # @validate_arguments()
        def create(cls, name: str) -> {{ entity_def.name }}.Attributes:
            if not name:
                raise ValueError("name cannot be blank")
            validate_required_fields(["name"], [name])
            return AuthPolicy.Attributes(
                qualified_name=name,
                name=name,
                display_name=""
            )
        {%- endif %}
    attributes: '{{entity_def.name}}.Attributes' = Field(
        default_factory = lambda: {{entity_def.name}}.Attributes(),
        description='Map of attributes in the instance and their values. The specific keys of this map will vary by '
                    'type, so are described in the sub-types of this schema.\n',
    )
    {%-  if entity_def.name == "Connection" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: str,
        connector_type: AtlanConnectorType,
        admin_users: Optional[list[str]] = None,
        admin_groups: Optional[list[str]] = None,
        admin_roles: Optional[list[str]] = None,
    )->{{ entity_def.name }}:
        if not name:
            raise ValueError("name cannot be blank")
        validate_required_fields(["connector_type"], [connector_type])
        if not admin_users and not admin_groups and not admin_roles:
            raise ValueError(
                "One of admin_user, admin_groups or admin_roles is required"
            )
        if admin_roles:
            from pyatlan.cache.role_cache import RoleCache
            for role_id in admin_roles:
                if not RoleCache.get_name_for_id(role_id):
                    raise ValueError(
                        f"Provided role ID {role_id} was not found in Atlan."
                    )
        if admin_groups:
            from pyatlan.cache.group_cache import GroupCache
            for group_alias in admin_groups:
                if not GroupCache.get_id_for_alias(group_alias):
                    raise ValueError(
                        f"Provided group name {group_alias} was not found in Atlan."
                    )
        if admin_users:
            from pyatlan.cache.user_cache import UserCache
            for username in admin_users:
                if not UserCache.get_id_for_name(username):
                    raise ValueError(
                        f"Provided username {username} was not found in Atlan."
                    )
        attr = cls.Attributes(
            name=name,
            qualified_name=connector_type.to_qualified_name(),
            connector_name=connector_type.value,
            category=connector_type.category.value,
            admin_users=admin_users or [],
            admin_groups=admin_groups or [],
            admin_roles=admin_roles or [],
        )
        return cls(attributes=attr)
    {%- elif entity_def.name == "Process" %}
    @classmethod
    def create(
        cls,
        name: str,
        connection_qualified_name: str,
        inputs: list["Catalog"],
        outputs: list["Catalog"],
        process_id: Optional[str] = None,
        parent: Optional[Process] = None,
    ) -> Process:
        return Process(
            attributes=Process.Attributes.create(
                name=name,
                connection_qualified_name=connection_qualified_name,
                process_id=process_id,
                inputs=inputs,
                outputs=outputs,
                parent=parent,
            )
        )
    {%- elif entity_def.name == "Database" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, connection_qualified_name: str)->{{ entity_def.name }}:
        if not name:
            raise ValueError("name cannot be blank")
        validate_required_fields(["connection_qualified_name"], [connection_qualified_name])
        fields = connection_qualified_name.split("/")
        if len(fields) != 3:
            raise ValueError("Invalid connection_qualified_name")
        try:
            connector_type = AtlanConnectorType(fields[1])  # type:ignore
        except ValueError as e:
            raise ValueError("Invalid connection_qualified_name") from e
        attributes = Database.Attributes(
            name=name,
            connection_qualified_name=connection_qualified_name,
            qualified_name=f"{connection_qualified_name}/{name}",
            connector_name=connector_type.value,
        )
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Schema" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, database_qualified_name: str)->{{ entity_def.name }}:
        validate_required_fields(["name", "database_qualified_name"], [name, database_qualified_name])
        attributes = Schema.Attributes.create(name=name, database_qualified_name=database_qualified_name)
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Table" or entity_def.name == "View" or entity_def.name == "MaterialisedView" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, schema_qualified_name: str)->{{ entity_def.name }}:
        validate_required_fields(["name", "schema_qualified_name"], [name, schema_qualified_name])
        attributes = {{ entity_def.name }}.Attributes.create(name=name, schema_qualified_name=schema_qualified_name)
        return cls(attributes=attributes)
    {%- elif entity_def.name == "S3Bucket" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls, *, name: str, connection_qualified_name: str, aws_arn: str
    ) -> {{ entity_def.name }}:
        validate_required_fields(
            ["name", "connection_qualified_name", "aws_arn"],
            [name, connection_qualified_name, aws_arn],
        )
        attributes = {{ entity_def.name }}.Attributes.create(
            name=name, connection_qualified_name=connection_qualified_name, aws_arn=aws_arn
        )
        return cls(attributes=attributes)
    {%- elif entity_def.name == "S3Object" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: str,
        connection_qualified_name: str,
        aws_arn: str,
        s3_bucket_qualified_name: Optional[str] = None,
    ) -> S3Object:
        validate_required_fields(
            ["name", "connection_qualified_name", "aws_arn"],
            [name, connection_qualified_name, aws_arn],
        )
        attributes = S3Object.Attributes.create(
            name=name,
            connection_qualified_name=connection_qualified_name,
            aws_arn=aws_arn,
            s3_bucket_qualified_name=s3_bucket_qualified_name
        )
        return cls(attributes=attributes)
    {%- elif entity_def.name == "Persona" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str) -> {{ entity_def.name }}:
        validate_required_fields(["name"], [name])
        attributes = Persona.Attributes.create(name=name)
        return cls(attributes=attributes)

    @classmethod
    # @validate_arguments()
    def create_metadata_policy(cls, *, name: str, persona_id: str, policy_type: AuthPolicyType, actions: Set[PersonaMetadataAction], resources: list[str]) -> AuthPolicy:
        validate_required_fields(["name", "persona_id", "policy_type", "actions", "resources"], [name, persona_id, policy_type, actions, resources])
        policy = AuthPolicy.create(name=name)
        policy.policy_actions = {x.value for x in actions}
        policy.policy_category = AuthPolicyCategory.PERSONA.value
        policy.policy_type = policy_type
        policy.policy_resources = resources
        policy.policy_resource_category = AuthPolicyResourceCategory.CUSTOM.value
        policy.policy_service_name = "atlas"
        policy.policy_sub_category = "metadata"
        persona = Persona()
        persona.guid = persona_id
        policy.access_control = persona
        return policy

    @classmethod
    # @validate_arguments()
    def create_data_policy(cls, *, name: str, persona_id: str, policy_type: AuthPolicyType, resources: list[str]) -> AuthPolicy:
        validate_required_fields(["name", "persona_id", "policy_type", "resources"], [name, persona_id, policy_type, resources])
        policy = AuthPolicy.create(name=name)
        policy.policy_actions = {DataAction.SELECT.value}
        policy.policy_category = AuthPolicyCategory.PERSONA.value
        policy.policy_type = policy_type
        policy.policy_resources = resources
        policy.policy_resources.append("entity-type:*")
        policy.policy_resource_category = AuthPolicyResourceCategory.ENTITY.value
        policy.policy_service_name = "heka"
        policy.policy_sub_category = "data"
        persona = Persona()
        persona.guid = persona_id
        policy.access_control = persona
        return policy

    @classmethod
    # @validate_arguments()
    def create_glossary_policy(cls, *, name: str, persona_id: str, policy_type: AuthPolicyType, actions: Set[PersonaGlossaryAction], resources: list[str]) -> AuthPolicy:
        validate_required_fields(["name", "persona_id", "policy_type", "actions", "resources"], [name, persona_id, policy_type, actions, resources])
        policy = AuthPolicy.create(name=name)
        policy.policy_actions = {x.value for x in actions}
        policy.policy_category = AuthPolicyCategory.PERSONA.value
        policy.policy_type = policy_type
        policy.policy_resources = resources
        policy.policy_resource_category = AuthPolicyResourceCategory.CUSTOM.value
        policy.policy_service_name = "atlas"
        policy.policy_sub_category = "glossary"
        persona = Persona()
        persona.guid = persona_id
        policy.access_control = persona
        return policy
    {%- elif entity_def.name == "Purpose" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str, classifications: list[str]) -> {{ entity_def.name }}:
        validate_required_fields(["name", "classifications"], [name, classifications])
        attributes = Purpose.Attributes.create(name=name, classifications=classifications)
        return cls(attributes=attributes)

    @classmethod
    # @validate_arguments()
    def create_metadata_policy(cls, *, name: str, purpose_id: str, policy_type: AuthPolicyType, actions: Set[PurposeMetadataAction], policy_groups: Optional[Set[str]] = None, policy_users: Optional[Set[str]] = None, all_users: bool = False) -> AuthPolicy:
        validate_required_fields(["name", "purpose_id", "policy_type", "actions"], [name, purpose_id, policy_type, actions])
        target_found = False
        policy = AuthPolicy.create(name=name)
        policy.policy_actions = {x.value for x in actions}
        policy.policy_category = AuthPolicyCategory.PURPOSE.value
        policy.policy_type = policy_type
        policy.policy_resource_category = AuthPolicyResourceCategory.TAG.value
        policy.policy_service_name = "atlas_tag"
        policy.policy_sub_category = "metadata"
        purpose = Purpose()
        purpose.guid = purpose_id
        policy.access_control = purpose
        if all_users:
            target_found = True
            policy.policy_groups = {"public"}
        else:
            if policy_groups:
                from pyatlan.cache.group_cache import GroupCache
                for group_alias in policy_groups:
                    if not GroupCache.get_id_for_alias(group_alias):
                        raise ValueError(
                            f"Provided group name {group_alias} was not found in Atlan."
                        )
                target_found = True
                policy.policy_groups = policy_groups
            else:
                policy.policy_groups = None
            if policy_users:
                from pyatlan.cache.user_cache import UserCache
                for username in policy_users:
                    if not UserCache.get_id_for_name(username):
                        raise ValueError(
                            f"Provided username {username} was not found in Atlan."
                        )
                target_found = True
                policy.policy_users = policy_users
            else:
                policy.policy_users = None
        if target_found:
            return policy
        else:
            raise ValueError(
                "No user or group specified for the policy."
            )

    @classmethod
    # @validate_arguments()
    def create_data_policy(cls, *, name: str, purpose_id: str, policy_type: AuthPolicyType, policy_groups: Optional[Set[str]] = None, policy_users: Optional[Set[str]] = None, all_users: bool = False) -> AuthPolicy:
        validate_required_fields(["name", "purpose_id", "policy_type"], [name, purpose_id, policy_type])
        policy = AuthPolicy.create(name=name)
        policy.policy_actions = {DataAction.SELECT.value}
        policy.policy_category = AuthPolicyCategory.PURPOSE.value
        policy.policy_type = policy_type
        policy.policy_resource_category = AuthPolicyResourceCategory.TAG.value
        policy.policy_service_name = "atlas_tag"
        policy.policy_sub_category = "data"
        purpose = Purpose()
        purpose.guid = purpose_id
        policy.access_control = purpose
        if all_users:
            target_found = True
            policy.policy_groups = {"public"}
        else:
            if policy_groups:
                from pyatlan.cache.group_cache import GroupCache
                for group_alias in policy_groups:
                    if not GroupCache.get_id_for_alias(group_alias):
                        raise ValueError(
                            f"Provided group name {group_alias} was not found in Atlan."
                        )
                target_found = True
                policy.policy_groups = policy_groups
            else:
                policy.policy_groups = None
            if policy_users:
                from pyatlan.cache.user_cache import UserCache
                for username in policy_users:
                    if not UserCache.get_id_for_name(username):
                        raise ValueError(
                            f"Provided username {username} was not found in Atlan."
                        )
                target_found = True
                policy.policy_users = policy_users
            else:
                policy.policy_users = None
        if target_found:
            return policy
        else:
            raise ValueError(
                "No user or group specified for the policy."
            )
    {%- elif entity_def.name == "AuthPolicy" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: str) -> {{ entity_def.name }}:
        validate_required_fields(["name"], [name])
        attributes = AuthPolicy.Attributes.create(name=name)
        return cls(attributes=attributes)
    {%- endif %}
    {% if entity_def.name == "Persona" or entity_def.name == "Purpose" %}
    @classmethod
    def create_for_modification(
        cls: type[SelfAsset],
        qualified_name: str = "",
        name: str = "",
        is_enabled: bool = True,
    ) -> SelfAsset:
        validate_required_fields(
            ["name", "qualified_name", "is_enabled"],
            [name, qualified_name, is_enabled],
        )
        return cls(
            attributes=cls.Attributes(
                qualified_name=qualified_name,
                name=name,
                is_access_control_enabled=is_enabled
            )
        )
    {%- endif %}
    {% if entity_def.name.startswith("AtlasGlossary") %}
    @root_validator()
    def update_qualified_name(cls, values):
        if "attributes" in values  and values["attributes"] and not values["attributes"].qualified_name:
            values["attributes"].qualified_name = values["guid"]
        return values
    {%- if entity_def.name == "AtlasGlossary" %}
    @classmethod
    # @validate_arguments()
    def create(cls, *, name: StrictStr)->{{ entity_def.name }}:
        validate_required_fields(["name"], [name])
        return AtlasGlossary(attributes=AtlasGlossary.Attributes.create(name=name))
    {% elif entity_def.name == "AtlasGlossaryCategory" %}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: StrictStr,
        anchor: AtlasGlossary,
        parent_category: Optional[AtlasGlossaryCategory] = None,
    ) -> AtlasGlossaryCategory:
        validate_required_fields(["name", "anchor"], [name, anchor])
        return cls(
            attributes=AtlasGlossaryCategory.Attributes.create(
                name=name, anchor=anchor, parent_category=parent_category
            )
        )

    def trim_to_required(self) -> AtlasGlossaryCategory:
        if self.anchor is None or not self.anchor.guid:
            raise ValueError("anchor.guid must be available")
        return self.create_for_modification(
            qualified_name=self.qualified_name,
            name=self.name,
            glossary_guid=self.anchor.guid,
        )

    @classmethod
    def create_for_modification(
        cls: type[SelfAsset],
        qualified_name: str = "",
        name: str = "",
        glossary_guid: str = "",
    ) -> SelfAsset:
        validate_required_fields(
            ["name", "qualified_name", "glossary_guid"],
            [name, qualified_name, glossary_guid],
        )
        glossary = AtlasGlossary()
        glossary.guid = glossary_guid
        return cls(
            attributes=cls.Attributes(
                qualified_name=qualified_name, name=name, anchor=glossary
            )
        )
    {% elif entity_def.name == "AtlasGlossaryTerm"%}
    @classmethod
    # @validate_arguments()
    def create(
        cls,
        *,
        name: StrictStr,
        anchor: Optional[AtlasGlossary] = None,
        glossary_qualified_name: Optional[StrictStr] = None,
        glossary_guid: Optional[StrictStr] = None,
        categories: Optional[list[AtlasGlossaryCategory]] = None,
    ) -> AtlasGlossaryTerm:
        validate_required_fields(["name"], [name])
        return cls(
            attributes=AtlasGlossaryTerm.Attributes.create(
                name=name, anchor=anchor, glossary_qualified_name=glossary_qualified_name,  glossary_guid = glossary_guid, categories=categories
            )
        )
    def trim_to_required(self) -> AtlasGlossaryTerm:
        if self.anchor is None or not self.anchor.guid:
            raise ValueError("anchor.guid must be available")
        return self.create_for_modification(
            qualified_name=self.qualified_name,
            name=self.name,
            glossary_guid=self.anchor.guid,
        )

    @classmethod
    def create_for_modification(
        cls: type[SelfAsset],
        qualified_name: str = "",
        name: str = "",
        glossary_guid: str = "",
    ) -> SelfAsset:
        validate_required_fields(
            ["name", "qualified_name", "glossary_guid"],
            [name, qualified_name, glossary_guid],
        )
        glossary = AtlasGlossary()
        glossary.guid = glossary_guid
        return cls(
            attributes=cls.Attributes(
                qualified_name=qualified_name, name=name, anchor=glossary
            )
        )
    {%- endif  %}
    {% endif %}
    {% if entity_def.name == "Asset" %}
    def has_announcement(self) -> bool:
        return bool(
            self.attributes
            and (
                self.attributes.announcement_title
                or self.attributes.announcement_type
            )
        )

    def set_announcement(self, announcement: Announcement) -> None:
        self.attributes.announcement_type = announcement.announcement_type.value
        self.attributes.announcement_title = announcement.announcement_title
        self.attributes.announcement_message = announcement.announcement_message

    def get_announcment(self) -> Optional[Announcement]:
        if self.attributes.announcement_type and self.attributes.announcement_title:
            return Announcement(
                announcement_type=AnnouncementType[
                    self.attributes.announcement_type.upper()
                ],
                announcement_title=self.attributes.announcement_title,
                announcement_message=self.attributes.announcement_message,
            )
        return None

    def remove_announcement(self):
        self.attributes.remove_announcement()

    def remove_description(self):
        self.attributes.remove_description()

    def remove_user_description(self):
        self.attributes.remove_user_description()

    def remove_owners(self):
        self.attributes.remove_owners()

    def remove_certificate(self):
        self.attributes.remove_certificate()
    {% endif %}
    {% endif %}
{%- endif %}
{% endfor %}
Referenceable.update_forward_refs()
AtlasGlossary.update_forward_refs()
{% for entity_def in entity_defs %}
{{entity_def.name}}.Attributes.update_forward_refs()
{% endfor %}

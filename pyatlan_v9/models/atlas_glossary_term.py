# Auto-generated by PythonMsgspecRenderer.pkl - DO NOT EDIT
# SPDX-License-Identifier: Apache-2.0
# Copyright 2024 Atlan Pte. Ltd.

"""
AtlasGlossaryTerm asset model with flattened inheritance.

This module provides:
- AtlasGlossaryTerm: Flat asset class (easy to use)
- AtlasGlossaryTermAttributes: Nested attributes struct (extends AssetAttributes)
- AtlasGlossaryTermNested: Nested API format struct
"""

from __future__ import annotations

from typing import Union

from msgspec import UNSET, UnsetType

from pyatlan_v9.conversion_utils import (
    build_attributes_kwargs,
    build_flat_kwargs,
    categorize_relationships,
    merge_relationships,
)
from pyatlan_v9.serde import Serde, get_serde
from pyatlan_v9.transform import register_asset
from pyatlan_v9.utils import init_guid, validate_required_fields

from .asset import Asset, AssetAttributes, AssetNested, AssetRelationshipAttributes
from .gtc_related import (
    RelatedAtlasGlossary,
    RelatedAtlasGlossaryCategory,
    RelatedAtlasGlossaryTerm,
)
from .referenceable_related import RelatedReferenceable

# =============================================================================
# FLAT ASSET CLASS
# =============================================================================


@register_asset
class AtlasGlossaryTerm(Asset):
    """
    Instance of a term in Atlan. Terms define concepts in natural language that can be associated with other assets to provide meaning.
    """

    # Override type_name with AtlasGlossaryTerm-specific default
    type_name: Union[str, UnsetType] = "AtlasGlossaryTerm"

    short_description: Union[str, None, UnsetType] = UNSET
    """Unused. Brief summary of the term. See 'description' and 'userDescription' instead."""

    long_description: Union[str, None, UnsetType] = UNSET
    """Unused. Detailed definition of the term. See 'readme' instead."""

    examples: Union[list[str], None, UnsetType] = UNSET
    """Unused. Exmaples of the term."""

    abbreviation: Union[str, None, UnsetType] = UNSET
    """Unused. Abbreviation of the term."""

    usage: Union[str, None, UnsetType] = UNSET
    """Unused. Intended usage for the term."""

    additional_attributes: Union[dict[str, str], None, UnsetType] = UNSET
    """Unused. Arbitrary set of additional attributes for the terrm."""

    term_type: Union[str, None, UnsetType] = UNSET
    """"""

    assigned_entities: Union[list[RelatedReferenceable], None, UnsetType] = UNSET
    """Assets assigned this term."""

    anchor: Union[RelatedAtlasGlossary, None, UnsetType] = UNSET
    """Glossary in which this term is contained."""

    categories: Union[list[RelatedAtlasGlossaryCategory], None, UnsetType] = UNSET
    """Categories within which this term is organized."""

    see_also: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Linked terms that may also be of interest."""

    synonyms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Terms that have the same (or a very similar) meaning, in the same language."""

    antonyms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Terms that have the opposite (or near opposite) meaning, in the same language."""

    preferred_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Preferred term(s) to use instead of this term."""

    preferred_to_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Other term(s) that are less common or less preferred than this term."""

    replaced_by: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) that must no longer be used."""

    replacement_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) that must be used instead."""

    translated_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) that are a translation of this term."""

    translation_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) for which this term is a translation."""

    classifies: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """More general term that defines a group of terms, for example: 'animal'."""

    is_a: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """More specific term that is a sub-class of another term, for example: 'cat'."""

    valid_values_for: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term for which this is a valid value."""

    valid_values: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Valid values for this term."""

    # =========================================================================
    # Convenience Methods
    # =========================================================================

    @classmethod
    @init_guid
    def creator(
        cls,
        *,
        name: str,
        anchor: "Asset | None" = None,
        glossary_qualified_name: str | None = None,
        glossary_guid: str | None = None,
        categories: list["RelatedAtlasGlossaryCategory"] | None = None,
    ) -> "AtlasGlossaryTerm":
        """
        Create a new AtlasGlossaryTerm asset.

        Args:
            name: Simple name of the term
            anchor: Glossary object in which this term is contained (mutually exclusive with glossary_qualified_name and glossary_guid)
            glossary_qualified_name: Qualified name of the glossary (mutually exclusive with anchor and glossary_guid)
            glossary_guid: GUID of the glossary (mutually exclusive with anchor and glossary_qualified_name)
            categories: Optional list of categories to which this term belongs

        Returns:
            New AtlasGlossaryTerm instance

        Raises:
            ValueError: If required parameters are missing or if multiple glossary identifiers are provided
        """
        validate_required_fields(["name"], [name])

        # Validate exactly one glossary identifier is provided
        provided_params = [
            p for p in [anchor, glossary_qualified_name, glossary_guid] if p is not None
        ]
        if len(provided_params) == 0:
            raise ValueError(
                "One of the following parameters are required: anchor, glossary_qualified_name, glossary_guid"
            )
        if len(provided_params) > 1:
            param_names = []
            if anchor is not None:
                param_names.append("anchor")
            if glossary_qualified_name is not None:
                param_names.append("glossary_qualified_name")
            if glossary_guid is not None:
                param_names.append("glossary_guid")
            raise ValueError(
                f"Only one of the following parameters are allowed: {', '.join(param_names)}"
            )

        # Generate qualified name
        import uuid

        qualified_name = f"{name}@{uuid.uuid4()}"

        # Create anchor reference based on which parameter was provided
        if anchor is not None:
            # Use provided anchor object
            from msgspec import UNSET as MSGSPEC_UNSET

            if hasattr(anchor, "trim_to_reference") and callable(
                anchor.trim_to_reference
            ):
                anchor_ref = anchor.trim_to_reference()
            else:
                # Fallback: create RelatedAtlasGlossary from anchor attributes
                anchor_ref = RelatedAtlasGlossary(
                    guid=anchor.guid
                    if hasattr(anchor, "guid") and anchor.guid is not MSGSPEC_UNSET
                    else None,
                    qualified_name=anchor.qualified_name
                    if hasattr(anchor, "qualified_name")
                    and anchor.qualified_name is not MSGSPEC_UNSET
                    else None,
                )
        elif glossary_qualified_name is not None:
            anchor_ref = RelatedAtlasGlossary(qualified_name=glossary_qualified_name)
        else:  # glossary_guid is not None
            anchor_ref = RelatedAtlasGlossary(guid=glossary_guid)

        return cls(
            name=name,
            qualified_name=qualified_name,
            anchor=anchor_ref,
            categories=categories,
        )

    @classmethod
    def updater(
        cls, *, qualified_name: str, name: str, glossary_guid: str
    ) -> "AtlasGlossaryTerm":
        """
        Create an AtlasGlossaryTerm instance for updating an existing term.

        Args:
            qualified_name: Unique name of the term to update
            name: Simple name of the term
            glossary_guid: GUID of the glossary containing this term

        Returns:
            AtlasGlossaryTerm instance configured for updates

        Raises:
            ValueError: If required parameters are missing
        """
        validate_required_fields(
            ["qualified_name", "name", "glossary_guid"],
            [qualified_name, name, glossary_guid],
        )
        return cls(
            qualified_name=qualified_name,
            name=name,
            anchor=RelatedAtlasGlossary(guid=glossary_guid),
        )

    def trim_to_required(self) -> "AtlasGlossaryTerm":
        """
        Return an AtlasGlossaryTerm with only required fields for reference.

        Returns:
            AtlasGlossaryTerm instance with only required fields set

        Raises:
            ValueError: If anchor or anchor.guid is not available
        """
        if self.anchor is None or self.anchor is UNSET:
            raise ValueError("anchor.guid must be available")
        if (
            not hasattr(self.anchor, "guid")
            or self.anchor.guid is None
            or self.anchor.guid is UNSET
        ):
            raise ValueError("anchor.guid must be available")

        return AtlasGlossaryTerm(
            qualified_name=self.qualified_name,
            name=self.name,
            anchor=RelatedAtlasGlossary(guid=self.anchor.guid),
        )

    # Backward compatibility aliases
    @classmethod
    def create(cls, **kwargs) -> "AtlasGlossaryTerm":
        """Backward compatibility alias for creator()."""
        return cls.creator(**kwargs)

    @classmethod
    def create_for_modification(cls, **kwargs) -> "AtlasGlossaryTerm":
        """Backward compatibility alias for updater()."""
        return cls.updater(**kwargs)

    # =========================================================================
    # Optimized Serialization Methods (override Asset base class)
    # =========================================================================

    def to_json(self, nested: bool = True, serde: Serde | None = None) -> str:
        """
        Convert to JSON string using optimized nested struct serialization.

        Args:
            nested: If True (default), use nested API format. If False, use flat format.
            serde: Optional Serde instance for encoder reuse. Uses shared singleton if None.

        Returns:
            JSON string representation
        """
        if serde is None:
            serde = get_serde()
        if nested:
            return _atlas_glossary_term_to_nested_bytes(self, serde).decode("utf-8")
        else:
            return serde.encode(self).decode("utf-8")

    @staticmethod
    def from_json(
        json_data: Union[str, bytes], serde: Serde | None = None
    ) -> "AtlasGlossaryTerm":
        """
        Create from JSON string or bytes using optimized nested struct deserialization.

        Args:
            json_data: JSON string or bytes to deserialize
            serde: Optional Serde instance for decoder reuse. Uses shared singleton if None.

        Returns:
            AtlasGlossaryTerm instance
        """
        if isinstance(json_data, str):
            json_data = json_data.encode("utf-8")
        if serde is None:
            serde = get_serde()
        return _atlas_glossary_term_from_nested_bytes(json_data, serde)


# =============================================================================
# NESTED FORMAT CLASSES
# =============================================================================


class AtlasGlossaryTermAttributes(AssetAttributes):
    """AtlasGlossaryTerm-specific attributes for nested API format."""

    short_description: Union[str, None, UnsetType] = UNSET
    """Unused. Brief summary of the term. See 'description' and 'userDescription' instead."""

    long_description: Union[str, None, UnsetType] = UNSET
    """Unused. Detailed definition of the term. See 'readme' instead."""

    examples: Union[list[str], None, UnsetType] = UNSET
    """Unused. Exmaples of the term."""

    abbreviation: Union[str, None, UnsetType] = UNSET
    """Unused. Abbreviation of the term."""

    usage: Union[str, None, UnsetType] = UNSET
    """Unused. Intended usage for the term."""

    additional_attributes: Union[dict[str, str], None, UnsetType] = UNSET
    """Unused. Arbitrary set of additional attributes for the terrm."""

    term_type: Union[str, None, UnsetType] = UNSET
    """"""


class AtlasGlossaryTermRelationshipAttributes(AssetRelationshipAttributes):
    """AtlasGlossaryTerm-specific relationship attributes for nested API format."""

    assigned_entities: Union[list[RelatedReferenceable], None, UnsetType] = UNSET
    """Assets assigned this term."""

    anchor: Union[RelatedAtlasGlossary, None, UnsetType] = UNSET
    """Glossary in which this term is contained."""

    categories: Union[list[RelatedAtlasGlossaryCategory], None, UnsetType] = UNSET
    """Categories within which this term is organized."""

    see_also: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Linked terms that may also be of interest."""

    synonyms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Terms that have the same (or a very similar) meaning, in the same language."""

    antonyms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Terms that have the opposite (or near opposite) meaning, in the same language."""

    preferred_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Preferred term(s) to use instead of this term."""

    preferred_to_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Other term(s) that are less common or less preferred than this term."""

    replaced_by: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) that must no longer be used."""

    replacement_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) that must be used instead."""

    translated_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) that are a translation of this term."""

    translation_terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term(s) for which this term is a translation."""

    classifies: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """More general term that defines a group of terms, for example: 'animal'."""

    is_a: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """More specific term that is a sub-class of another term, for example: 'cat'."""

    valid_values_for: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Term for which this is a valid value."""

    valid_values: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Valid values for this term."""


class AtlasGlossaryTermNested(AssetNested):
    """AtlasGlossaryTerm in nested API format for high-performance serialization."""

    attributes: Union[AtlasGlossaryTermAttributes, UnsetType] = UNSET
    relationship_attributes: Union[
        AtlasGlossaryTermRelationshipAttributes, UnsetType
    ] = UNSET
    append_relationship_attributes: Union[
        AtlasGlossaryTermRelationshipAttributes, UnsetType
    ] = UNSET
    remove_relationship_attributes: Union[
        AtlasGlossaryTermRelationshipAttributes, UnsetType
    ] = UNSET


# =============================================================================
# CONVERSION FUNCTIONS
# =============================================================================


def _atlas_glossary_term_to_nested(
    atlas_glossary_term: AtlasGlossaryTerm,
) -> AtlasGlossaryTermNested:
    """Convert flat AtlasGlossaryTerm to nested format using dynamic field extraction."""
    # Build attributes using dynamic field extraction
    attrs_kwargs = build_attributes_kwargs(
        atlas_glossary_term, AtlasGlossaryTermAttributes
    )
    attrs = AtlasGlossaryTermAttributes(**attrs_kwargs)

    # Categorize relationships by save semantic (REPLACE, APPEND, REMOVE)
    rel_fields: list[str] = [
        "assigned_entities",
        "anchor",
        "categories",
        "see_also",
        "synonyms",
        "antonyms",
        "preferred_terms",
        "preferred_to_terms",
        "replaced_by",
        "replacement_terms",
        "translated_terms",
        "translation_terms",
        "classifies",
        "is_a",
        "valid_values_for",
        "valid_values",
    ]
    replace_rels, append_rels, remove_rels = categorize_relationships(
        atlas_glossary_term, rel_fields, AtlasGlossaryTermRelationshipAttributes
    )

    return AtlasGlossaryTermNested(
        guid=atlas_glossary_term.guid,
        type_name=atlas_glossary_term.type_name,
        status=atlas_glossary_term.status,
        version=atlas_glossary_term.version,
        create_time=atlas_glossary_term.create_time,
        update_time=atlas_glossary_term.update_time,
        created_by=atlas_glossary_term.created_by,
        updated_by=atlas_glossary_term.updated_by,
        classifications=atlas_glossary_term.classifications,
        classification_names=atlas_glossary_term.classification_names,
        meanings=atlas_glossary_term.meanings,
        labels=atlas_glossary_term.labels,
        business_attributes=atlas_glossary_term.business_attributes,
        custom_attributes=atlas_glossary_term.custom_attributes,
        pending_tasks=atlas_glossary_term.pending_tasks,
        proxy=atlas_glossary_term.proxy,
        is_incomplete=atlas_glossary_term.is_incomplete,
        provenance_type=atlas_glossary_term.provenance_type,
        home_id=atlas_glossary_term.home_id,
        attributes=attrs,
        relationship_attributes=replace_rels,
        append_relationship_attributes=append_rels,
        remove_relationship_attributes=remove_rels,
    )


def _atlas_glossary_term_from_nested(
    nested: AtlasGlossaryTermNested,
) -> AtlasGlossaryTerm:
    """Convert nested format to flat AtlasGlossaryTerm using dynamic field extraction."""
    attrs = (
        nested.attributes
        if nested.attributes is not UNSET
        else AtlasGlossaryTermAttributes()
    )

    # Merge relationships from all three buckets
    rel_fields: list[str] = [
        "assigned_entities",
        "anchor",
        "categories",
        "see_also",
        "synonyms",
        "antonyms",
        "preferred_terms",
        "preferred_to_terms",
        "replaced_by",
        "replacement_terms",
        "translated_terms",
        "translation_terms",
        "classifies",
        "is_a",
        "valid_values_for",
        "valid_values",
    ]
    merged_rels = merge_relationships(
        nested.relationship_attributes,
        nested.append_relationship_attributes,
        nested.remove_relationship_attributes,
        rel_fields,
        AtlasGlossaryTermRelationshipAttributes,
    )

    # Build flat kwargs using dynamic field extraction
    kwargs = build_flat_kwargs(
        nested, attrs, merged_rels, AssetNested, AtlasGlossaryTermAttributes
    )

    return AtlasGlossaryTerm(**kwargs)


def _atlas_glossary_term_to_nested_bytes(
    atlas_glossary_term: AtlasGlossaryTerm, serde: Serde
) -> bytes:
    """Convert flat AtlasGlossaryTerm to nested JSON bytes."""
    return serde.encode(_atlas_glossary_term_to_nested(atlas_glossary_term))


def _atlas_glossary_term_from_nested_bytes(
    data: bytes, serde: Serde
) -> AtlasGlossaryTerm:
    """Convert nested JSON bytes to flat AtlasGlossaryTerm."""
    nested = serde.decode(data, AtlasGlossaryTermNested)
    return _atlas_glossary_term_from_nested(nested)

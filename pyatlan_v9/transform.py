# Auto-generated by PythonMsgspecRenderer.pkl - DO NOT EDIT
"""
Transform utilities for converting between flattened SDK format and Atlas API format.

The SDK uses flattened attributes (e.g., `entity.name`) while the Atlas API uses
nested attributes (e.g., `entity.attributes.name`). This module handles the
bidirectional conversion.

Field name conversion (snake_case <-> camelCase) is handled automatically by
msgspec's rename="camel" configuration on the Asset base class.
"""

from __future__ import annotations

import importlib
import re
from typing import Any, TypeVar

_T = TypeVar("_T")

import msgspec

from pyatlan_v9.models.asset import Asset

# Type registry - maps type names to classes
# Populated via @register_asset decorator or lazy loading in get_type()
_type_registry: dict[str, type] = {}

# Track failed lazy imports to avoid repeated attempts
_failed_imports: set[str] = set()


def _get_type_name_default(cls: type) -> str | None:
    """Extract the type_name default value from a msgspec Struct class.

    For msgspec Structs, class attributes become field descriptors, so we need
    to use msgspec.structs.fields() to get the actual default value.
    """
    try:
        for field in msgspec.structs.fields(cls):
            if field.name == "type_name":
                default = field.default
                if isinstance(default, str) and default != "UNSET":
                    return default
                return None
    except TypeError:
        # Not a msgspec Struct - fall back to getattr
        pass

    # Fallback for non-Struct classes
    type_name = getattr(cls, "type_name", None)
    if isinstance(type_name, str) and type_name != "UNSET":
        return type_name
    return None


def register_asset(cls: _T) -> _T:
    """Decorator that registers an Asset subclass in the type registry.

    Use this decorator on Asset subclasses to enable automatic deserialization
    to the correct type when fetching from the API.

    Example:
        from pyatlan_v9.transform import register_asset

        @register_asset
        class AtlasGlossaryTerm(Asset):
            type_name: Union[str, UnsetType] = "AtlasGlossaryTerm"
            ...

    The class is registered under its `type_name` field's default value.
    Works with both msgspec Structs and regular classes.
    """
    type_name = _get_type_name_default(cls)
    if type_name:
        _type_registry[type_name] = cls
    return cls


def _type_name_to_module(type_name: str) -> str:
    """Convert a type name to its module path.

    Converts CamelCase type names to snake_case module names.
    Examples:
        AtlasGlossaryTerm -> pyatlan.models.atlas_glossary_term
        S3Bucket -> pyatlan.models.s3_bucket
        APIField -> pyatlan.models.api_field
    """
    # Handle consecutive capitals (e.g., API -> api, S3 -> s3)
    # Insert underscore before a capital that's followed by lowercase
    # or before a capital that follows a lowercase
    s1 = re.sub(r"(.)([A-Z][a-z]+)", r"\1_\2", type_name)
    snake_case = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", s1).lower()
    return f"pyatlan.models.{snake_case}"


def get_type(type_name: str) -> type:
    """Get the Python class for an Atlas type name.

    This uses a hybrid approach:
    1. Fast path: Return from registry if already registered (via decorator or previous load)
    2. Lazy load: If not registered, derive module name and import on-demand

    Returns the registered class if found, otherwise falls back to Asset.
    """
    # Fast path: already registered
    if type_name in _type_registry:
        return _type_registry[type_name]

    # Skip if we already tried and failed to import this type
    if type_name in _failed_imports:
        return Asset

    # Lazy load: derive module from type name and import
    module_name = _type_name_to_module(type_name)
    try:
        importlib.import_module(module_name)
        # The @register_asset decorator should have registered the class
        return _type_registry.get(type_name, Asset)
    except ImportError:
        # Module doesn't exist - remember this to avoid repeated attempts
        _failed_imports.add(type_name)
        return Asset


# Mapping of snake_case SDK field names to camelCase Atlas field names for top-level fields
TOP_LEVEL_MAPPING = {
    "guid": "guid",
    "type_name": "typeName",
    "status": "status",
    "created_by": "createdBy",
    "create_time": "createTime",
    "updated_by": "updatedBy",
    "update_time": "updateTime",
    "version": "version",
}

# Reverse mapping for decoding (camelCase -> snake_case)
TOP_LEVEL_MAPPING_REVERSE = {v: k for k, v in TOP_LEVEL_MAPPING.items()}


def to_atlas_format(asset: Asset) -> dict[str, Any]:
    """Convert a flattened msgspec Struct to Atlas API format.

    Takes an SDK entity with flattened attributes and converts it to the
    nested format expected by the Atlas API.

    Args:
        asset: The Asset instance to convert.

    Returns:
        A dictionary in Atlas API format with nested attributes.
    """
    # Use msgspec to encode to JSON bytes, then decode to dict
    # The Struct's rename="camel" handles snake_case -> camelCase conversion
    json_bytes = msgspec.json.encode(asset)
    data = msgspec.json.decode(json_bytes, type=dict)

    # Restructure: move non-top-level fields into attributes
    # Use type_name instance attribute (or class default) to get the type name
    type_name = getattr(asset, "type_name", None) or type(asset).__name__
    result: dict[str, Any] = {"typeName": type_name}
    attributes: dict[str, Any] = {}

    top_level_keys = {
        "guid",
        "typeName",
        "status",
        "createdBy",
        "createTime",
        "updatedBy",
        "updateTime",
        "version",
    }

    for key, value in data.items():
        if value is None:
            continue
        if key in top_level_keys:
            result[key] = value
        else:
            attributes[key] = value

    if attributes:
        result["attributes"] = attributes

    return result


def from_atlas_format(data: dict[str, Any]) -> Asset:
    """Convert Atlas API format to a flattened msgspec Struct.

    Takes an entity from the Atlas API and converts it to the SDK's
    flattened attribute format.

    Args:
        data: A dictionary in Atlas API format.

    Returns:
        The appropriate Asset subclass instance with flattened attributes.
    """
    type_name = data.get("typeName", "Asset")
    cls = get_type(type_name)

    # Flatten: merge top-level fields with attributes
    # Keys stay in camelCase - msgspec's rename="camel" handles conversion
    flattened: dict[str, Any] = {}

    # Copy top-level fields (already in camelCase)
    for key in (
        "guid",
        "typeName",
        "status",
        "createdBy",
        "createTime",
        "updatedBy",
        "updateTime",
        "version",
        "docId",
        "superTypeNames",
        "isIncomplete",
        "labels",
        "classifications",
    ):
        if key in data:
            flattened[key] = data[key]

    # Merge attributes (already in camelCase)
    if data.get("attributes"):
        flattened.update(data["attributes"])

    # Merge relationshipAttributes (already in camelCase)
    if data.get("relationshipAttributes"):
        flattened.update(data["relationshipAttributes"])

    # msgspec.convert with rename="camel" on Asset handles camelCase -> snake_case
    return msgspec.convert(flattened, cls, strict=False)


def from_atlas_json(json_bytes: bytes, type_name: str | None = None) -> Asset:  # noqa: ARG001
    """Convert Atlas API JSON bytes directly to a flattened msgspec Struct.

    This is the fastest path - parses JSON and converts in minimal steps.

    Args:
        json_bytes: Raw JSON bytes from the API response.
        type_name: Optional type name hint (if known ahead of time).

    Returns:
        The appropriate Asset subclass instance with flattened attributes.
    """
    # First, decode to dict to extract structure
    data = msgspec.json.decode(json_bytes, type=dict)

    # Handle wrapped response format {"entity": {...}}
    if "entity" in data:
        data = data["entity"]

    return from_atlas_format(data)


def to_bulk_payload(entities: list[Asset]) -> dict[str, Any]:
    """Convert a list of entities to the bulk API payload format.

    Args:
        entities: List of Asset instances to include in the payload.

    Returns:
        A dictionary formatted for the /entity/bulk endpoint.
    """
    return {"entities": [to_atlas_format(e) for e in entities]}

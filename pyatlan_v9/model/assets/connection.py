# Auto-generated by PythonMsgspecRenderer.pkl - DO NOT EDIT
# SPDX-License-Identifier: Apache-2.0
# Copyright 2024 Atlan Pte. Ltd.

"""
Connection asset model with flattened inheritance.

This module provides:
- Connection: Flat asset class (easy to use)
- ConnectionAttributes: Nested attributes struct (extends AssetAttributes)
- ConnectionNested: Nested API format struct
"""

from __future__ import annotations

from typing import TYPE_CHECKING, List, Optional, Union

from msgspec import UNSET, UnsetType

from pyatlan.model.enums import AtlanConnectorType
from pyatlan_v9.model.conversion_utils import (
    build_attributes_kwargs,
    build_flat_kwargs,
    categorize_relationships,
    merge_relationships,
)
from pyatlan_v9.model.serde import Serde, get_serde
from pyatlan_v9.model.transform import register_asset
from pyatlan_v9.utils import init_guid, validate_required_fields

from .asset import Asset, AssetAttributes, AssetNested, AssetRelationshipAttributes

if TYPE_CHECKING:
    from pyatlan.client.atlan import AtlanClient


# =============================================================================
# FLAT ASSET CLASS
# =============================================================================


@register_asset
class Connection(Asset):
    """
    Instance of a connection to a data source in Atlan.
    """

    # Override type_name with Connection-specific default
    type_name: Union[str, UnsetType] = "Connection"

    category: Union[str, None, UnsetType] = UNSET
    """Type of connection, for example WAREHOUSE, RDBMS, etc."""

    sub_category: Union[str, None, UnsetType] = UNSET
    """Subcategory of this connection."""

    host: Union[str, None, UnsetType] = UNSET
    """Host name of this connection's source."""

    port: Union[int, None, UnsetType] = UNSET
    """Port number to this connection's source."""

    allow_query: Union[bool, None, UnsetType] = UNSET
    """Whether using this connection to run queries on the source is allowed (true) or not (false)."""

    allow_query_preview: Union[bool, None, UnsetType] = UNSET
    """Whether using this connection to run preview queries on the source is allowed (true) or not (false)."""

    query_preview_config: Union[dict[str, str], None, UnsetType] = UNSET
    """Configuration for preview queries."""

    connection_workflow_configuration: Union[dict[str, str], None, UnsetType] = UNSET
    """Configuration for a workflow run."""

    query_config: Union[str, None, UnsetType] = UNSET
    """Query config for this connection."""

    credential_strategy: Union[str, None, UnsetType] = UNSET
    """Credential strategy to use for this connection for queries."""

    preview_credential_strategy: Union[str, None, UnsetType] = UNSET
    """Credential strategy to use for this connection for preview queries."""

    policy_strategy: Union[str, None, UnsetType] = UNSET
    """Policy strategy is a configuration that determines whether the Atlan policy will be applied to the results of insight queries and whether the query will be rewritten, applicable for stream api call made from insight screen"""

    policy_strategy_for_sample_preview: Union[str, None, UnsetType] = UNSET
    """Policy strategy is a configuration that determines whether the Atlan policy will be applied to the results of insight queries and whether the query will be rewritten. policyStrategyForSamplePreview config is applicable for sample preview call from assets screen"""

    query_username_strategy: Union[str, None, UnsetType] = UNSET
    """Username strategy to use for this connection for queries."""

    row_limit: Union[int, None, UnsetType] = UNSET
    """Maximum number of rows that can be returned for the source."""

    query_timeout: Union[int, None, UnsetType] = UNSET
    """Maximum time a query should be allowed to run before timing out."""

    default_credential_guid: Union[str, None, UnsetType] = UNSET
    """Unique identifier (GUID) for the default credentials to use for this connection."""

    connection_dq_credential_guid: Union[str, None, UnsetType] = UNSET
    """Unique identifier (GUID) for the data quality credentials to use for this connection."""

    connection_is_dq_enabled: Union[bool, None, UnsetType] = UNSET
    """Whether data quality is enabled for this connection (true) or not (false)."""

    connection_dq_environment_setup_status: Union[str, None, UnsetType] = UNSET
    """Status of the data quality environment setup for this connection."""

    connection_dq_environment_setup_error_message: Union[str, None, UnsetType] = UNSET
    """Error message if data quality environment setup failed for this connection."""

    connection_dq_environment_setup_status_updated_at: Union[int, None, UnsetType] = (
        UNSET
    )
    """Timestamp when the data quality environment setup status was last updated."""

    connection_dq_environment_source_database_name: Union[str, None, UnsetType] = UNSET
    """Name of the database in the source environment for data quality."""

    connector_icon: Union[str, None, UnsetType] = UNSET
    """Unused. Only the value of connectorType impacts icons."""

    connector_image: Union[str, None, UnsetType] = UNSET
    """Unused. Only the value of connectorType impacts icons."""

    source_logo: Union[str, None, UnsetType] = UNSET
    """Unused. Only the value of connectorType impacts icons."""

    is_sample_data_preview_enabled: Union[bool, None, UnsetType] = UNSET
    """Whether sample data can be previewed for this connection (true) or not (false)."""

    popularity_insights_timeframe: Union[int, None, UnsetType] = UNSET
    """Number of days over which popularity is calculated, for example 30 days."""

    has_popularity_insights: Union[bool, None, UnsetType] = UNSET
    """Whether this connection has popularity insights (true) or not (false)."""

    connection_dbt_environments: Union[list[str], None, UnsetType] = UNSET
    """"""

    connection_sso_credential_guid: Union[str, None, UnsetType] = UNSET
    """Unique identifier (GUID) for the SSO credentials to use for this connection."""

    use_object_storage: Union[bool, None, UnsetType] = UNSET
    """Whether to upload to S3, GCP, or another storage location (true) or not (false)."""

    connection_insights_via_o_auth_cookie: Union[bool, None, UnsetType] = UNSET
    """Whether cookie based OAuth is enabled in Insights for this connection (true) or not (false)."""

    object_storage_upload_threshold: Union[int, None, UnsetType] = UNSET
    """Number of rows after which results should be uploaded to storage."""

    vector_embeddings_enabled: Union[bool, None, UnsetType] = UNSET
    """"""

    vector_embeddings_updated_at: Union[int, None, UnsetType] = UNSET
    """"""

    # =========================================================================
    # Convenience Methods
    # =========================================================================

    @classmethod
    @init_guid
    def creator(
        cls,
        *,
        client: AtlanClient,
        name: str,
        connector_type: AtlanConnectorType,
        admin_users: Optional[List[str]] = None,
        admin_groups: Optional[List[str]] = None,
        admin_roles: Optional[List[str]] = None,
        host: Optional[str] = None,
        port: Optional[int] = None,
    ) -> "Connection":
        """
        Create a new Connection asset.

        Args:
            client: AtlanClient for cache validation
            name: Simple name of the connection
            connector_type: Type of connector for the connection
            admin_users: List of admin usernames
            admin_groups: List of admin group names
            admin_roles: List of admin role GUIDs
            host: Optional hostname for the connection
            port: Optional port number for the connection

        Returns:
            New Connection instance with all fields populated

        Raises:
            ValueError: If required parameters are missing or invalid
        """
        validate_required_fields(
            ["client", "name", "connector_type"], [client, name, connector_type]
        )
        if not admin_users and not admin_groups and not admin_roles:
            raise ValueError(
                "One of admin_user, admin_groups or admin_roles is required"
            )
        client.user_cache.validate_names(names=admin_users or [])
        client.role_cache.validate_idstrs(idstrs=admin_roles or [])
        client.group_cache.validate_aliases(aliases=admin_groups or [])

        return cls(
            name=name,
            qualified_name=connector_type.to_qualified_name(),
            connector_name=connector_type.value,
            category=connector_type.category.value,
            admin_users=set() if admin_users is None else set(admin_users),
            admin_groups=set() if admin_groups is None else set(admin_groups),
            admin_roles=set() if admin_roles is None else set(admin_roles),
            host=host,
            port=port,
        )

    @classmethod
    def updater(cls, *, qualified_name: str, name: str) -> "Connection":
        """
        Create a Connection instance for updating an existing asset.

        Args:
            qualified_name: Unique name of the connection to update
            name: Simple name of the connection

        Returns:
            Connection instance configured for updates

        Raises:
            ValueError: If required parameters are missing
        """
        validate_required_fields(["qualified_name", "name"], [qualified_name, name])
        return cls(qualified_name=qualified_name, name=name)

    def trim_to_required(self) -> "Connection":
        """
        Return a Connection with only required fields for reference.

        Returns:
            Connection instance with only qualified_name and name set
        """
        return Connection(qualified_name=self.qualified_name, name=self.name)

    # Backward compatibility aliases
    @classmethod
    def create(cls, **kwargs) -> "Connection":
        """Backward compatibility alias for creator()."""
        return cls.creator(**kwargs)

    @classmethod
    def create_for_modification(cls, **kwargs) -> "Connection":
        """Backward compatibility alias for updater()."""
        return cls.updater(**kwargs)

    # =========================================================================
    # Optimized Serialization Methods (override Asset base class)
    # =========================================================================

    def to_json(self, nested: bool = True, serde: Serde | None = None) -> str:
        """
        Convert to JSON string using optimized nested struct serialization.

        Args:
            nested: If True (default), use nested API format. If False, use flat format.
            serde: Optional Serde instance for encoder reuse. Uses shared singleton if None.

        Returns:
            JSON string representation
        """
        if serde is None:
            serde = get_serde()
        if nested:
            return _connection_to_nested_bytes(self, serde).decode("utf-8")
        else:
            return serde.encode(self).decode("utf-8")

    @staticmethod
    def from_json(
        json_data: Union[str, bytes], serde: Serde | None = None
    ) -> "Connection":
        """
        Create from JSON string or bytes using optimized nested struct deserialization.

        Args:
            json_data: JSON string or bytes to deserialize
            serde: Optional Serde instance for decoder reuse. Uses shared singleton if None.

        Returns:
            Connection instance
        """
        if isinstance(json_data, str):
            json_data = json_data.encode("utf-8")
        if serde is None:
            serde = get_serde()
        return _connection_from_nested_bytes(json_data, serde)


# =============================================================================
# NESTED FORMAT CLASSES
# =============================================================================


class ConnectionAttributes(AssetAttributes):
    """Connection-specific attributes for nested API format."""

    category: Union[str, None, UnsetType] = UNSET
    """Type of connection, for example WAREHOUSE, RDBMS, etc."""

    sub_category: Union[str, None, UnsetType] = UNSET
    """Subcategory of this connection."""

    host: Union[str, None, UnsetType] = UNSET
    """Host name of this connection's source."""

    port: Union[int, None, UnsetType] = UNSET
    """Port number to this connection's source."""

    allow_query: Union[bool, None, UnsetType] = UNSET
    """Whether using this connection to run queries on the source is allowed (true) or not (false)."""

    allow_query_preview: Union[bool, None, UnsetType] = UNSET
    """Whether using this connection to run preview queries on the source is allowed (true) or not (false)."""

    query_preview_config: Union[dict[str, str], None, UnsetType] = UNSET
    """Configuration for preview queries."""

    connection_workflow_configuration: Union[dict[str, str], None, UnsetType] = UNSET
    """Configuration for a workflow run."""

    query_config: Union[str, None, UnsetType] = UNSET
    """Query config for this connection."""

    credential_strategy: Union[str, None, UnsetType] = UNSET
    """Credential strategy to use for this connection for queries."""

    preview_credential_strategy: Union[str, None, UnsetType] = UNSET
    """Credential strategy to use for this connection for preview queries."""

    policy_strategy: Union[str, None, UnsetType] = UNSET
    """Policy strategy is a configuration that determines whether the Atlan policy will be applied to the results of insight queries and whether the query will be rewritten, applicable for stream api call made from insight screen"""

    policy_strategy_for_sample_preview: Union[str, None, UnsetType] = UNSET
    """Policy strategy is a configuration that determines whether the Atlan policy will be applied to the results of insight queries and whether the query will be rewritten. policyStrategyForSamplePreview config is applicable for sample preview call from assets screen"""

    query_username_strategy: Union[str, None, UnsetType] = UNSET
    """Username strategy to use for this connection for queries."""

    row_limit: Union[int, None, UnsetType] = UNSET
    """Maximum number of rows that can be returned for the source."""

    query_timeout: Union[int, None, UnsetType] = UNSET
    """Maximum time a query should be allowed to run before timing out."""

    default_credential_guid: Union[str, None, UnsetType] = UNSET
    """Unique identifier (GUID) for the default credentials to use for this connection."""

    connection_dq_credential_guid: Union[str, None, UnsetType] = UNSET
    """Unique identifier (GUID) for the data quality credentials to use for this connection."""

    connection_is_dq_enabled: Union[bool, None, UnsetType] = UNSET
    """Whether data quality is enabled for this connection (true) or not (false)."""

    connection_dq_environment_setup_status: Union[str, None, UnsetType] = UNSET
    """Status of the data quality environment setup for this connection."""

    connection_dq_environment_setup_error_message: Union[str, None, UnsetType] = UNSET
    """Error message if data quality environment setup failed for this connection."""

    connection_dq_environment_setup_status_updated_at: Union[int, None, UnsetType] = (
        UNSET
    )
    """Timestamp when the data quality environment setup status was last updated."""

    connection_dq_environment_source_database_name: Union[str, None, UnsetType] = UNSET
    """Name of the database in the source environment for data quality."""

    connector_icon: Union[str, None, UnsetType] = UNSET
    """Unused. Only the value of connectorType impacts icons."""

    connector_image: Union[str, None, UnsetType] = UNSET
    """Unused. Only the value of connectorType impacts icons."""

    source_logo: Union[str, None, UnsetType] = UNSET
    """Unused. Only the value of connectorType impacts icons."""

    is_sample_data_preview_enabled: Union[bool, None, UnsetType] = UNSET
    """Whether sample data can be previewed for this connection (true) or not (false)."""

    popularity_insights_timeframe: Union[int, None, UnsetType] = UNSET
    """Number of days over which popularity is calculated, for example 30 days."""

    has_popularity_insights: Union[bool, None, UnsetType] = UNSET
    """Whether this connection has popularity insights (true) or not (false)."""

    connection_dbt_environments: Union[list[str], None, UnsetType] = UNSET
    """"""

    connection_sso_credential_guid: Union[str, None, UnsetType] = UNSET
    """Unique identifier (GUID) for the SSO credentials to use for this connection."""

    use_object_storage: Union[bool, None, UnsetType] = UNSET
    """Whether to upload to S3, GCP, or another storage location (true) or not (false)."""

    connection_insights_via_o_auth_cookie: Union[bool, None, UnsetType] = UNSET
    """Whether cookie based OAuth is enabled in Insights for this connection (true) or not (false)."""

    object_storage_upload_threshold: Union[int, None, UnsetType] = UNSET
    """Number of rows after which results should be uploaded to storage."""

    vector_embeddings_enabled: Union[bool, None, UnsetType] = UNSET
    """"""

    vector_embeddings_updated_at: Union[int, None, UnsetType] = UNSET
    """"""


class ConnectionRelationshipAttributes(AssetRelationshipAttributes):
    """Connection-specific relationship attributes for nested API format."""

    pass


class ConnectionNested(AssetNested):
    """Connection in nested API format for high-performance serialization."""

    attributes: Union[ConnectionAttributes, UnsetType] = UNSET
    relationship_attributes: Union[ConnectionRelationshipAttributes, UnsetType] = UNSET
    append_relationship_attributes: Union[
        ConnectionRelationshipAttributes, UnsetType
    ] = UNSET
    remove_relationship_attributes: Union[
        ConnectionRelationshipAttributes, UnsetType
    ] = UNSET


# =============================================================================
# CONVERSION FUNCTIONS
# =============================================================================


def _connection_to_nested(connection: Connection) -> ConnectionNested:
    """Convert flat Connection to nested format using dynamic field extraction."""
    attrs_kwargs = build_attributes_kwargs(connection, ConnectionAttributes)
    attrs = ConnectionAttributes(**attrs_kwargs)
    # Categorize relationships by save semantic (REPLACE, APPEND, REMOVE)
    rel_fields: list[str] = []
    replace_rels, append_rels, remove_rels = categorize_relationships(
        connection, rel_fields, ConnectionRelationshipAttributes
    )
    return ConnectionNested(
        guid=connection.guid,
        type_name=connection.type_name,
        status=connection.status,
        version=connection.version,
        create_time=connection.create_time,
        update_time=connection.update_time,
        created_by=connection.created_by,
        updated_by=connection.updated_by,
        classifications=connection.classifications,
        classification_names=connection.classification_names,
        meanings=connection.meanings,
        labels=connection.labels,
        business_attributes=connection.business_attributes,
        custom_attributes=connection.custom_attributes,
        pending_tasks=connection.pending_tasks,
        proxy=connection.proxy,
        is_incomplete=connection.is_incomplete,
        provenance_type=connection.provenance_type,
        home_id=connection.home_id,
        attributes=attrs,
        relationship_attributes=replace_rels,
        append_relationship_attributes=append_rels,
        remove_relationship_attributes=remove_rels,
    )


def _connection_from_nested(nested: ConnectionNested) -> Connection:
    """Convert nested format to flat Connection using dynamic field extraction."""
    attrs = (
        nested.attributes if nested.attributes is not UNSET else ConnectionAttributes()
    )

    # Merge relationships from all three buckets
    rel_fields: list[str] = []
    merged_rels = merge_relationships(
        nested.relationship_attributes,
        nested.append_relationship_attributes,
        nested.remove_relationship_attributes,
        rel_fields,
        ConnectionRelationshipAttributes,
    )

    # Build flat kwargs using dynamic field extraction
    kwargs = build_flat_kwargs(
        nested, attrs, merged_rels, AssetNested, ConnectionAttributes
    )

    return Connection(**kwargs)


def _connection_to_nested_bytes(connection: Connection, serde: Serde) -> bytes:
    """Convert flat Connection to nested JSON bytes."""
    return serde.encode(_connection_to_nested(connection))


def _connection_from_nested_bytes(data: bytes, serde: Serde) -> Connection:
    """Convert nested JSON bytes to flat Connection."""
    nested = serde.decode(data, ConnectionNested)
    return _connection_from_nested(nested)

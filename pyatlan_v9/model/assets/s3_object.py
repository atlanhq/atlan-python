# Auto-generated by PythonMsgspecRenderer.pkl - DO NOT EDIT
# SPDX-License-Identifier: Apache-2.0
# Copyright 2024 Atlan Pte. Ltd.

"""
S3Object asset model with flattened inheritance.

This module provides:
- S3Object: Flat asset class (easy to use)
- S3ObjectAttributes: Nested attributes struct (extends AssetAttributes)
- S3ObjectNested: Nested API format struct
"""

from __future__ import annotations

from typing import Any, Union

from msgspec import UNSET, UnsetType

from pyatlan.model.utils import construct_object_key
from pyatlan_v9.model.conversion_utils import (
    build_attributes_kwargs,
    build_flat_kwargs,
    categorize_relationships,
    merge_relationships,
)
from pyatlan_v9.model.serde import Serde, get_serde
from pyatlan_v9.model.transform import register_asset
from pyatlan_v9.utils import init_guid, validate_required_fields

from .asset import Asset, AssetAttributes, AssetNested, AssetRelationshipAttributes
from .s3_related import RelatedS3Bucket, RelatedS3Prefix

# =============================================================================
# FLAT ASSET CLASS
# =============================================================================


@register_asset
class S3Object(Asset):
    """
    Instance of an S3 object in Atlan.
    """

    # Override type_name with S3Object-specific default
    type_name: Union[str, UnsetType] = "S3Object"

    s3_object_last_modified_time: Union[int, None, UnsetType] = UNSET
    """Time (epoch) at which this object was last updated, in milliseconds, or when it was created if it has never been modified."""

    s3_bucket_name: Union[str, None, UnsetType] = UNSET
    """Simple name of the bucket in which this object exists."""

    s3_bucket_qualified_name: Union[str, None, UnsetType] = UNSET
    """Unique name of the bucket in which this object exists."""

    s3_object_size: Union[int, None, UnsetType] = UNSET
    """Object size in bytes."""

    s3_object_storage_class: Union[str, None, UnsetType] = UNSET
    """Storage class used for storing this object, for example: standard, intelligent-tiering, glacier, etc."""

    s3_object_key: Union[str, None, UnsetType] = UNSET
    """Unique identity of this object in an S3 bucket. This is usually the concatenation of any prefix (folder) in the S3 bucket with the name of the object (file) itself."""

    s3_object_content_type: Union[str, None, UnsetType] = UNSET
    """Type of content in this object, for example: text/plain, application/json, etc."""

    s3_object_content_disposition: Union[str, None, UnsetType] = UNSET
    """Information about how this object's content should be presented."""

    s3_object_version_id: Union[str, None, UnsetType] = UNSET
    """Version of this object. This is only applicable when versioning is enabled on the bucket in which this object exists."""

    s3_object_lock_retain_until: Union[int, None, UnsetType] = UNSET
    """Time (epoch) when the object lock retention will expire."""

    s3_object_lock_mode: Union[str, None, UnsetType] = UNSET
    """Mode of the object lock retention."""

    s3_object_lock_legal_hold_enabled: Union[bool, None, UnsetType] = UNSET
    """Whether the object lock legal hold is enabled (true) or not (false)."""

    s3_e_tag: Union[str, None, UnsetType] = UNSET
    """Entity tag for the asset. An entity tag is a hash of the object and represents changes to the contents of an object only, not its metadata."""

    s3_encryption: Union[str, None, UnsetType] = UNSET
    """"""

    s3_parent_prefix_qualified_name: Union[str, None, UnsetType] = UNSET
    """Unique name of the immediate parent prefix in which this asset exists."""

    s3_prefix_hierarchy: Union[list[dict[str, str]], None, UnsetType] = UNSET
    """Ordered array of prefix assets with qualified name and name representing the complete prefix hierarchy path for this asset, from immediate parent to root prefix."""

    aws_arn: Union[str, None, UnsetType] = UNSET
    """Amazon Resource Name (ARN) for this asset. This uniquely identifies the asset in AWS, and thus must be unique across all AWS asset instances."""

    aws_partition: Union[str, None, UnsetType] = UNSET
    """Group of AWS region and service objects."""

    aws_service: Union[str, None, UnsetType] = UNSET
    """Type of service in which the asset exists."""

    aws_region: Union[str, None, UnsetType] = UNSET
    """Physical region where the data center in which the asset exists is clustered."""

    aws_account_id: Union[str, None, UnsetType] = UNSET
    """12-digit number that uniquely identifies an AWS account."""

    aws_resource_id: Union[str, None, UnsetType] = UNSET
    """Unique resource ID assigned when a new resource is created."""

    aws_owner_name: Union[str, None, UnsetType] = UNSET
    """Root user's name."""

    aws_owner_id: Union[str, None, UnsetType] = UNSET
    """Root user's ID."""

    aws_tags: Union[list[dict[str, Any]], None, UnsetType] = UNSET
    """List of tags that have been applied to the asset in AWS."""

    bucket: Union[RelatedS3Bucket, None, UnsetType] = UNSET
    """S3 bucket in which the object exists."""

    s3_prefix: Union[RelatedS3Prefix, None, UnsetType] = UNSET
    """S3 prefix that contains the object."""

    # =========================================================================
    # Creator Methods
    # =========================================================================

    @classmethod
    @init_guid
    def creator(
        cls,
        *,
        name: str,
        connection_qualified_name: str,
        aws_arn: str,
        s3_bucket_name: str,
        s3_bucket_qualified_name: str,
    ) -> "S3Object":
        """
        Create a new S3Object asset with an AWS ARN.

        Args:
            name: Name of the object
            connection_qualified_name: Unique name of the connection
            aws_arn: Amazon Resource Name (ARN) for the object
            s3_bucket_name: Simple name of the bucket
            s3_bucket_qualified_name: Unique name of the bucket

        Returns:
            S3Object instance ready to be created

        Raises:
            ValueError: If required parameters are missing or invalid
        """
        validate_required_fields(
            [
                "name",
                "connection_qualified_name",
                "aws_arn",
                "s3_bucket_name",
                "s3_bucket_qualified_name",
            ],
            [
                name,
                connection_qualified_name,
                aws_arn,
                s3_bucket_name,
                s3_bucket_qualified_name,
            ],
        )
        fields = connection_qualified_name.split("/")
        if len(fields) != 3:
            raise ValueError("Invalid connection_qualified_name")
        if fields[0].replace(" ", "") == "" or fields[2].replace(" ", "") == "":
            raise ValueError("Invalid connection_qualified_name")
        if fields[1].lower() != "s3":
            raise ValueError("Invalid connection_qualified_name")

        connector_name = fields[1]
        return cls(
            name=name,
            connection_qualified_name=connection_qualified_name,
            qualified_name=f"{connection_qualified_name}/{aws_arn}",
            connector_name=connector_name,
            aws_arn=aws_arn,
            s3_bucket_name=s3_bucket_name,
            s3_bucket_qualified_name=s3_bucket_qualified_name,
        )

    @classmethod
    @init_guid
    def creator_with_prefix(
        cls,
        *,
        name: str,
        connection_qualified_name: str,
        s3_bucket_name: str,
        s3_bucket_qualified_name: str,
        prefix: str = "",
    ) -> "S3Object":
        """
        Create a new S3Object asset using a prefix-based object key.

        Args:
            name: Name of the object
            connection_qualified_name: Unique name of the connection
            s3_bucket_name: Simple name of the bucket
            s3_bucket_qualified_name: Unique name of the bucket
            prefix: Prefix (folder path) for the object

        Returns:
            S3Object instance ready to be created

        Raises:
            ValueError: If required parameters are missing or invalid
        """
        validate_required_fields(
            [
                "name",
                "connection_qualified_name",
                "s3_bucket_name",
                "s3_bucket_qualified_name",
            ],
            [
                name,
                connection_qualified_name,
                s3_bucket_name,
                s3_bucket_qualified_name,
            ],
        )
        fields = connection_qualified_name.split("/")
        if len(fields) != 3:
            raise ValueError("Invalid connection_qualified_name")
        if fields[0].replace(" ", "") == "" or fields[2].replace(" ", "") == "":
            raise ValueError("Invalid connection_qualified_name")
        if fields[1].lower() != "s3":
            raise ValueError("Invalid connection_qualified_name")

        connector_name = fields[1]
        object_key = construct_object_key(prefix, name)
        return cls(
            name=name,
            s3_object_key=object_key,
            connection_qualified_name=connection_qualified_name,
            qualified_name=f"{connection_qualified_name}/{s3_bucket_name}/{object_key}",
            connector_name=connector_name,
            s3_bucket_name=s3_bucket_name,
            s3_bucket_qualified_name=s3_bucket_qualified_name,
        )

    @classmethod
    def updater(cls, *, qualified_name: str, name: str) -> "S3Object":
        """
        Create an S3Object instance for modification.

        Args:
            qualified_name: Unique name of the S3Object to update
            name: Human-readable name of the S3Object

        Returns:
            S3Object instance ready for update

        Raises:
            ValueError: If required parameters are missing
        """
        validate_required_fields(["qualified_name", "name"], [qualified_name, name])
        return cls(qualified_name=qualified_name, name=name)

    def trim_to_required(self) -> "S3Object":
        """
        Return a copy of this S3Object with only the minimum required fields for update.

        Returns:
            S3Object with only qualified_name and name set
        """
        return S3Object.updater(qualified_name=self.qualified_name, name=self.name)

    # =========================================================================
    # Optimized Serialization Methods (override Asset base class)
    # =========================================================================

    def to_json(self, nested: bool = True, serde: Serde | None = None) -> str:
        """
        Convert to JSON string using optimized nested struct serialization.

        Args:
            nested: If True (default), use nested API format. If False, use flat format.
            serde: Optional Serde instance for encoder reuse. Uses shared singleton if None.

        Returns:
            JSON string representation
        """
        if serde is None:
            serde = get_serde()
        if nested:
            return _s3_object_to_nested_bytes(self, serde).decode("utf-8")
        else:
            return serde.encode(self).decode("utf-8")

    @staticmethod
    def from_json(
        json_data: Union[str, bytes], serde: Serde | None = None
    ) -> "S3Object":
        """
        Create from JSON string or bytes using optimized nested struct deserialization.

        Args:
            json_data: JSON string or bytes to deserialize
            serde: Optional Serde instance for decoder reuse. Uses shared singleton if None.

        Returns:
            S3Object instance
        """
        if isinstance(json_data, str):
            json_data = json_data.encode("utf-8")
        if serde is None:
            serde = get_serde()
        return _s3_object_from_nested_bytes(json_data, serde)


# =============================================================================
# NESTED FORMAT CLASSES
# =============================================================================


class S3ObjectAttributes(AssetAttributes):
    """S3Object-specific attributes for nested API format."""

    s3_object_last_modified_time: Union[int, None, UnsetType] = UNSET
    """Time (epoch) at which this object was last updated, in milliseconds, or when it was created if it has never been modified."""

    s3_bucket_name: Union[str, None, UnsetType] = UNSET
    """Simple name of the bucket in which this object exists."""

    s3_bucket_qualified_name: Union[str, None, UnsetType] = UNSET
    """Unique name of the bucket in which this object exists."""

    s3_object_size: Union[int, None, UnsetType] = UNSET
    """Object size in bytes."""

    s3_object_storage_class: Union[str, None, UnsetType] = UNSET
    """Storage class used for storing this object, for example: standard, intelligent-tiering, glacier, etc."""

    s3_object_key: Union[str, None, UnsetType] = UNSET
    """Unique identity of this object in an S3 bucket. This is usually the concatenation of any prefix (folder) in the S3 bucket with the name of the object (file) itself."""

    s3_object_content_type: Union[str, None, UnsetType] = UNSET
    """Type of content in this object, for example: text/plain, application/json, etc."""

    s3_object_content_disposition: Union[str, None, UnsetType] = UNSET
    """Information about how this object's content should be presented."""

    s3_object_version_id: Union[str, None, UnsetType] = UNSET
    """Version of this object. This is only applicable when versioning is enabled on the bucket in which this object exists."""

    s3_object_lock_retain_until: Union[int, None, UnsetType] = UNSET
    """Time (epoch) when the object lock retention will expire."""

    s3_object_lock_mode: Union[str, None, UnsetType] = UNSET
    """Mode of the object lock retention."""

    s3_object_lock_legal_hold_enabled: Union[bool, None, UnsetType] = UNSET
    """Whether the object lock legal hold is enabled (true) or not (false)."""

    s3_e_tag: Union[str, None, UnsetType] = UNSET
    """Entity tag for the asset. An entity tag is a hash of the object and represents changes to the contents of an object only, not its metadata."""

    s3_encryption: Union[str, None, UnsetType] = UNSET
    """"""

    s3_parent_prefix_qualified_name: Union[str, None, UnsetType] = UNSET
    """Unique name of the immediate parent prefix in which this asset exists."""

    s3_prefix_hierarchy: Union[list[dict[str, str]], None, UnsetType] = UNSET
    """Ordered array of prefix assets with qualified name and name representing the complete prefix hierarchy path for this asset, from immediate parent to root prefix."""

    aws_arn: Union[str, None, UnsetType] = UNSET
    """Amazon Resource Name (ARN) for this asset. This uniquely identifies the asset in AWS, and thus must be unique across all AWS asset instances."""

    aws_partition: Union[str, None, UnsetType] = UNSET
    """Group of AWS region and service objects."""

    aws_service: Union[str, None, UnsetType] = UNSET
    """Type of service in which the asset exists."""

    aws_region: Union[str, None, UnsetType] = UNSET
    """Physical region where the data center in which the asset exists is clustered."""

    aws_account_id: Union[str, None, UnsetType] = UNSET
    """12-digit number that uniquely identifies an AWS account."""

    aws_resource_id: Union[str, None, UnsetType] = UNSET
    """Unique resource ID assigned when a new resource is created."""

    aws_owner_name: Union[str, None, UnsetType] = UNSET
    """Root user's name."""

    aws_owner_id: Union[str, None, UnsetType] = UNSET
    """Root user's ID."""

    aws_tags: Union[list[dict[str, Any]], None, UnsetType] = UNSET
    """List of tags that have been applied to the asset in AWS."""


class S3ObjectRelationshipAttributes(AssetRelationshipAttributes):
    """S3Object-specific relationship attributes for nested API format."""

    bucket: Union[RelatedS3Bucket, None, UnsetType] = UNSET
    """S3 bucket in which the object exists."""

    s3_prefix: Union[RelatedS3Prefix, None, UnsetType] = UNSET
    """S3 prefix that contains the object."""


class S3ObjectNested(AssetNested):
    """S3Object in nested API format for high-performance serialization."""

    attributes: Union[S3ObjectAttributes, UnsetType] = UNSET
    relationship_attributes: Union[S3ObjectRelationshipAttributes, UnsetType] = UNSET
    append_relationship_attributes: Union[S3ObjectRelationshipAttributes, UnsetType] = (
        UNSET
    )
    remove_relationship_attributes: Union[S3ObjectRelationshipAttributes, UnsetType] = (
        UNSET
    )


# =============================================================================
# CONVERSION FUNCTIONS
# =============================================================================


def _s3_object_to_nested(s3_object: S3Object) -> S3ObjectNested:
    """Convert flat S3Object to nested format."""
    attrs_kwargs = build_attributes_kwargs(s3_object, S3ObjectAttributes)
    attrs = S3ObjectAttributes(**attrs_kwargs)
    # Categorize relationships by save semantic (REPLACE, APPEND, REMOVE)
    rel_fields: list[str] = ["bucket", "s3_prefix"]
    replace_rels, append_rels, remove_rels = categorize_relationships(
        s3_object, rel_fields, S3ObjectRelationshipAttributes
    )
    return S3ObjectNested(
        guid=s3_object.guid,
        type_name=s3_object.type_name,
        status=s3_object.status,
        version=s3_object.version,
        create_time=s3_object.create_time,
        update_time=s3_object.update_time,
        created_by=s3_object.created_by,
        updated_by=s3_object.updated_by,
        classifications=s3_object.classifications,
        classification_names=s3_object.classification_names,
        meanings=s3_object.meanings,
        labels=s3_object.labels,
        business_attributes=s3_object.business_attributes,
        custom_attributes=s3_object.custom_attributes,
        pending_tasks=s3_object.pending_tasks,
        proxy=s3_object.proxy,
        is_incomplete=s3_object.is_incomplete,
        provenance_type=s3_object.provenance_type,
        home_id=s3_object.home_id,
        attributes=attrs,
        relationship_attributes=replace_rels,
        append_relationship_attributes=append_rels,
        remove_relationship_attributes=remove_rels,
    )


def _s3_object_from_nested(nested: S3ObjectNested) -> S3Object:
    """Convert nested format to flat S3Object."""
    attrs = (
        nested.attributes if nested.attributes is not UNSET else S3ObjectAttributes()
    )
    rel_fields: list[str] = ["bucket", "s3_prefix"]
    merged_rels = merge_relationships(
        nested.relationship_attributes,
        nested.append_relationship_attributes,
        nested.remove_relationship_attributes,
        rel_fields,
        S3ObjectRelationshipAttributes,
    )
    kwargs = build_flat_kwargs(
        nested, attrs, merged_rels, AssetNested, S3ObjectAttributes
    )
    return S3Object(**kwargs)


def _s3_object_to_nested_bytes(s3_object: S3Object, serde: Serde) -> bytes:
    """Convert flat S3Object to nested JSON bytes."""
    return serde.encode(_s3_object_to_nested(s3_object))


def _s3_object_from_nested_bytes(data: bytes, serde: Serde) -> S3Object:
    """Convert nested JSON bytes to flat S3Object."""
    nested = serde.decode(data, S3ObjectNested)
    return _s3_object_from_nested(nested)

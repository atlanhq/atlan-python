# Auto-generated by PythonMsgspecRenderer.pkl - DO NOT EDIT
# SPDX-License-Identifier: Apache-2.0
# Copyright 2024 Atlan Pte. Ltd.

"""
AtlasGlossaryCategory asset model with flattened inheritance.

This module provides:
- AtlasGlossaryCategory: Flat asset class (easy to use)
- AtlasGlossaryCategoryAttributes: Nested attributes struct (extends AssetAttributes)
- AtlasGlossaryCategoryNested: Nested API format struct
"""

from __future__ import annotations

from typing import Union

from msgspec import UNSET, UnsetType

from pyatlan_v9.model.conversion_utils import (
    build_attributes_kwargs,
    build_flat_kwargs,
    categorize_relationships,
    merge_relationships,
)
from pyatlan_v9.model.serde import Serde, get_serde
from pyatlan_v9.model.transform import register_asset
from pyatlan_v9.utils import init_guid, validate_required_fields

from .asset import Asset, AssetAttributes, AssetNested, AssetRelationshipAttributes
from .gtc_related import (
    RelatedAtlasGlossary,
    RelatedAtlasGlossaryCategory,
    RelatedAtlasGlossaryTerm,
)

# =============================================================================
# FLAT ASSET CLASS
# =============================================================================


@register_asset
class AtlasGlossaryCategory(Asset):
    """
    Instance of a category in Atlan, an organizational construct for glossary terms.
    """

    # Override type_name with AtlasGlossaryCategory-specific default
    type_name: Union[str, UnsetType] = "AtlasGlossaryCategory"

    short_description: Union[str, None, UnsetType] = UNSET
    """Unused. Brief summary of the category. See 'description' and 'userDescription' instead."""

    long_description: Union[str, None, UnsetType] = UNSET
    """Unused. Detailed description of the category. See 'readme' instead."""

    additional_attributes: Union[dict[str, str], None, UnsetType] = UNSET
    """Unused. Arbitrary set of additional attributes associated with the category."""

    category_type: Union[str, None, UnsetType] = UNSET
    """"""

    terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Terms organized within this category."""

    anchor: Union[RelatedAtlasGlossary, None, UnsetType] = UNSET
    """Glossary in which this category is contained."""

    children_categories: Union[list[RelatedAtlasGlossaryCategory], None, UnsetType] = (
        UNSET
    )
    """Child categories organized within this category."""

    parent_category: Union[RelatedAtlasGlossaryCategory, None, UnsetType] = UNSET
    """Parent category in which this category is located (or empty if this is a root-level category)."""

    # =========================================================================
    # Convenience Methods
    # =========================================================================

    @classmethod
    @init_guid
    def creator(
        cls,
        *,
        name: str,
        anchor: "Asset",
        parent_category: "AtlasGlossaryCategory | None" = None,
    ) -> "AtlasGlossaryCategory":
        """
        Create a new AtlasGlossaryCategory asset.

        Args:
            name: Simple name of the category
            anchor: Glossary object in which this category is contained
            parent_category: Optional parent category for this category

        Returns:
            New AtlasGlossaryCategory instance

        Raises:
            ValueError: If required parameters are missing
        """
        validate_required_fields(["name"], [name])

        # Generate qualified name
        import uuid

        qualified_name = f"{name}@{uuid.uuid4()}"

        # Create anchor reference from provided anchor object
        from msgspec import UNSET as MSGSPEC_UNSET

        if hasattr(anchor, "trim_to_reference") and callable(anchor.trim_to_reference):
            anchor_ref = anchor.trim_to_reference()
        else:
            # Fallback: create RelatedAtlasGlossary from anchor attributes
            anchor_ref = RelatedAtlasGlossary(
                guid=anchor.guid
                if hasattr(anchor, "guid") and anchor.guid is not MSGSPEC_UNSET
                else None,
                qualified_name=anchor.qualified_name
                if hasattr(anchor, "qualified_name")
                and anchor.qualified_name is not MSGSPEC_UNSET
                else None,
            )

        # Create parent category reference if provided
        parent_ref = None
        if parent_category is not None:
            if hasattr(parent_category, "trim_to_reference") and callable(
                parent_category.trim_to_reference
            ):
                parent_ref = parent_category.trim_to_reference()
            else:
                parent_ref = RelatedAtlasGlossaryCategory(
                    guid=parent_category.guid
                    if hasattr(parent_category, "guid")
                    and parent_category.guid is not MSGSPEC_UNSET
                    else None,
                    qualified_name=parent_category.qualified_name
                    if hasattr(parent_category, "qualified_name")
                    and parent_category.qualified_name is not MSGSPEC_UNSET
                    else None,
                )

        return cls(
            name=name,
            qualified_name=qualified_name,
            anchor=anchor_ref,
            parent_category=parent_ref,
        )

    @classmethod
    def updater(
        cls, *, qualified_name: str, name: str, glossary_guid: str
    ) -> "AtlasGlossaryCategory":
        """
        Create an AtlasGlossaryCategory instance for updating an existing category.

        Args:
            qualified_name: Unique name of the category to update
            name: Simple name of the category
            glossary_guid: GUID of the glossary containing this category

        Returns:
            AtlasGlossaryCategory instance configured for updates

        Raises:
            ValueError: If required parameters are missing
        """
        validate_required_fields(
            ["qualified_name", "name", "glossary_guid"],
            [qualified_name, name, glossary_guid],
        )
        return cls(
            qualified_name=qualified_name,
            name=name,
            anchor=RelatedAtlasGlossary(guid=glossary_guid),
        )

    def trim_to_required(self) -> "AtlasGlossaryCategory":
        """
        Return an AtlasGlossaryCategory with only required fields for reference.

        Returns:
            AtlasGlossaryCategory instance with only required fields set

        Raises:
            ValueError: If anchor or anchor.guid is not available
        """
        if self.anchor is None or self.anchor is UNSET:
            raise ValueError("anchor.guid must be available")
        if (
            not hasattr(self.anchor, "guid")
            or self.anchor.guid is None
            or self.anchor.guid is UNSET
        ):
            raise ValueError("anchor.guid must be available")

        return AtlasGlossaryCategory(
            qualified_name=self.qualified_name,
            name=self.name,
            anchor=RelatedAtlasGlossary(guid=self.anchor.guid),
        )

    # Backward compatibility aliases
    @classmethod
    def create(cls, **kwargs) -> "AtlasGlossaryCategory":
        """Backward compatibility alias for creator()."""
        return cls.creator(**kwargs)

    @classmethod
    def create_for_modification(cls, **kwargs) -> "AtlasGlossaryCategory":
        """Backward compatibility alias for updater()."""
        return cls.updater(**kwargs)

    # =========================================================================
    # Optimized Serialization Methods (override Asset base class)
    # =========================================================================

    def to_json(self, nested: bool = True, serde: Serde | None = None) -> str:
        """
        Convert to JSON string using optimized nested struct serialization.

        Args:
            nested: If True (default), use nested API format. If False, use flat format.
            serde: Optional Serde instance for encoder reuse. Uses shared singleton if None.

        Returns:
            JSON string representation
        """
        if serde is None:
            serde = get_serde()
        if nested:
            return _atlas_glossary_category_to_nested_bytes(self, serde).decode("utf-8")
        else:
            return serde.encode(self).decode("utf-8")

    @staticmethod
    def from_json(
        json_data: Union[str, bytes], serde: Serde | None = None
    ) -> "AtlasGlossaryCategory":
        """
        Create from JSON string or bytes using optimized nested struct deserialization.

        Args:
            json_data: JSON string or bytes to deserialize
            serde: Optional Serde instance for decoder reuse. Uses shared singleton if None.

        Returns:
            AtlasGlossaryCategory instance
        """
        if isinstance(json_data, str):
            json_data = json_data.encode("utf-8")
        if serde is None:
            serde = get_serde()
        return _atlas_glossary_category_from_nested_bytes(json_data, serde)


# =============================================================================
# NESTED FORMAT CLASSES
# =============================================================================


class AtlasGlossaryCategoryAttributes(AssetAttributes):
    """AtlasGlossaryCategory-specific attributes for nested API format."""

    short_description: Union[str, None, UnsetType] = UNSET
    """Unused. Brief summary of the category. See 'description' and 'userDescription' instead."""

    long_description: Union[str, None, UnsetType] = UNSET
    """Unused. Detailed description of the category. See 'readme' instead."""

    additional_attributes: Union[dict[str, str], None, UnsetType] = UNSET
    """Unused. Arbitrary set of additional attributes associated with the category."""

    category_type: Union[str, None, UnsetType] = UNSET
    """"""


class AtlasGlossaryCategoryRelationshipAttributes(AssetRelationshipAttributes):
    """AtlasGlossaryCategory-specific relationship attributes for nested API format."""

    terms: Union[list[RelatedAtlasGlossaryTerm], None, UnsetType] = UNSET
    """Terms organized within this category."""

    anchor: Union[RelatedAtlasGlossary, None, UnsetType] = UNSET
    """Glossary in which this category is contained."""

    children_categories: Union[list[RelatedAtlasGlossaryCategory], None, UnsetType] = (
        UNSET
    )
    """Child categories organized within this category."""

    parent_category: Union[RelatedAtlasGlossaryCategory, None, UnsetType] = UNSET
    """Parent category in which this category is located (or empty if this is a root-level category)."""


class AtlasGlossaryCategoryNested(AssetNested):
    """AtlasGlossaryCategory in nested API format for high-performance serialization."""

    attributes: Union[AtlasGlossaryCategoryAttributes, UnsetType] = UNSET
    relationship_attributes: Union[
        AtlasGlossaryCategoryRelationshipAttributes, UnsetType
    ] = UNSET
    append_relationship_attributes: Union[
        AtlasGlossaryCategoryRelationshipAttributes, UnsetType
    ] = UNSET
    remove_relationship_attributes: Union[
        AtlasGlossaryCategoryRelationshipAttributes, UnsetType
    ] = UNSET


# =============================================================================
# CONVERSION FUNCTIONS
# =============================================================================


def _atlas_glossary_category_to_nested(
    atlas_glossary_category: AtlasGlossaryCategory,
) -> AtlasGlossaryCategoryNested:
    """Convert flat AtlasGlossaryCategory to nested format using dynamic field extraction."""
    # Build attributes using dynamic field extraction
    attrs_kwargs = build_attributes_kwargs(
        atlas_glossary_category, AtlasGlossaryCategoryAttributes
    )
    attrs = AtlasGlossaryCategoryAttributes(**attrs_kwargs)

    # Categorize relationships by save semantic (REPLACE, APPEND, REMOVE)
    rel_fields: list[str] = [
        "terms",
        "anchor",
        "children_categories",
        "parent_category",
    ]
    replace_rels, append_rels, remove_rels = categorize_relationships(
        atlas_glossary_category, rel_fields, AtlasGlossaryCategoryRelationshipAttributes
    )

    return AtlasGlossaryCategoryNested(
        guid=atlas_glossary_category.guid,
        type_name=atlas_glossary_category.type_name,
        status=atlas_glossary_category.status,
        version=atlas_glossary_category.version,
        create_time=atlas_glossary_category.create_time,
        update_time=atlas_glossary_category.update_time,
        created_by=atlas_glossary_category.created_by,
        updated_by=atlas_glossary_category.updated_by,
        classifications=atlas_glossary_category.classifications,
        classification_names=atlas_glossary_category.classification_names,
        meanings=atlas_glossary_category.meanings,
        labels=atlas_glossary_category.labels,
        business_attributes=atlas_glossary_category.business_attributes,
        custom_attributes=atlas_glossary_category.custom_attributes,
        pending_tasks=atlas_glossary_category.pending_tasks,
        proxy=atlas_glossary_category.proxy,
        is_incomplete=atlas_glossary_category.is_incomplete,
        provenance_type=atlas_glossary_category.provenance_type,
        home_id=atlas_glossary_category.home_id,
        attributes=attrs,
        relationship_attributes=replace_rels,
        append_relationship_attributes=append_rels,
        remove_relationship_attributes=remove_rels,
    )


def _atlas_glossary_category_from_nested(
    nested: AtlasGlossaryCategoryNested,
) -> AtlasGlossaryCategory:
    """Convert nested format to flat AtlasGlossaryCategory using dynamic field extraction."""
    attrs = (
        nested.attributes
        if nested.attributes is not UNSET
        else AtlasGlossaryCategoryAttributes()
    )

    # Merge relationships from all three buckets
    rel_fields: list[str] = [
        "terms",
        "anchor",
        "children_categories",
        "parent_category",
    ]
    merged_rels = merge_relationships(
        nested.relationship_attributes,
        nested.append_relationship_attributes,
        nested.remove_relationship_attributes,
        rel_fields,
        AtlasGlossaryCategoryRelationshipAttributes,
    )

    # Build flat kwargs using dynamic field extraction
    kwargs = build_flat_kwargs(
        nested, attrs, merged_rels, AssetNested, AtlasGlossaryCategoryAttributes
    )

    return AtlasGlossaryCategory(**kwargs)


def _atlas_glossary_category_to_nested_bytes(
    atlas_glossary_category: AtlasGlossaryCategory, serde: Serde
) -> bytes:
    """Convert flat AtlasGlossaryCategory to nested JSON bytes."""
    return serde.encode(_atlas_glossary_category_to_nested(atlas_glossary_category))


def _atlas_glossary_category_from_nested_bytes(
    data: bytes, serde: Serde
) -> AtlasGlossaryCategory:
    """Convert nested JSON bytes to flat AtlasGlossaryCategory."""
    nested = serde.decode(data, AtlasGlossaryCategoryNested)
    return _atlas_glossary_category_from_nested(nested)
